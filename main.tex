\documentclass[a4paper,10pt]{book}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\usepackage{amsmath}
\usepackage{color,soul}
\usepackage{fancyhdr}
\geometry{margin=1in}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{calc}
\usepackage{nameref}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{fix-cm}
\usepackage{titlesec}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{tcolorbox}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage{setspace}  
\usepackage{ragged2e}  
\usepackage{tocloft} 
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  urlcolor=blue,
  pdftitle={Project Index},
}
% Define professional color scheme
\definecolor{headerblue}{RGB}{41, 82, 163}
\definecolor{lightgray}{RGB}{245, 245, 245}
\definecolor{bordercolor}{RGB}{180, 180, 180}
\definecolor{headingcolor}{RGB}{180,70,57}
\definecolor{rclr}{HTML}{DB7093}
\definecolor{c1}{HTML}{AFDDFF}
\definecolor{c2}{HTML}{A1EEBD}
\definecolor{c3}{HTML}{A6D6D6}
\definecolor{c4}{HTML}{FFD586}
\definecolor{c5}{HTML}{DC143C}
% Define custom colors
\definecolor{darkblue}{RGB}{25, 42, 86}
\definecolor{lightblue}{RGB}{70, 130, 180}
\definecolor{accent}{RGB}{255, 215, 0}
\definecolor{textgray}{RGB}{60, 60, 60}

\definecolor{bgcolor}{rgb}{0.8, 0.9, 0.5} % 
\definecolor{bgcolor1}{rgb}{0.95, 0.95, 0.95} % Light Gray
\definecolor{bgcolor2}{rgb}{0.85, 0.92, 1.0}  % Soft Blue
\definecolor{bgcolor3}{rgb}{0.9, 0.85, 1.0}   % Light Purple
\definecolor{bgcolor4}{rgb}{0.95, 0.88, 0.76} % Warm Beige
\definecolor{bgcolor5}{rgb}{0.8, 0.95, 0.8}   % Gentle Green
\definecolor{bgcolor6}{rgb}{1.0, 0.87, 0.87}  % Pastel Red
\definecolor{bgcolor7}{rgb}{0.86, 0.93, 0.83} % Mint Green
\definecolor{bgcolor8}{rgb}{0.98, 0.85, 0.94} % Soft Pink
\definecolor{bgcolor9}{rgb}{0.87, 0.94, 0.98} % Sky Blue
\definecolor{bgcolor10}{rgb}{0.96, 0.96, 0.82} % Pale Yellow
\begin{document}
\include{copyfront}
\clearpage
\tableofcontents
\clearpage
\include{copyintro}
\newgeometry{margin=0.2in}

% Professional header command
% \newcommand{\tableheader}[1]{\textcolor{white}{\textbf{#1}}}
\newcounter{tablerow}
\newcommand{\tablerowcolor}{%
    \stepcounter{tablerow}%
    \ifodd\value{tablerow}%
        \rowcolor{white}%
    \else%
        \rowcolor{lightgray}%
    \fi%
}
% Reset row counter for new tables
\newcommand{\resettablerows}{\setcounter{tablerow}{0}}

% Store original environments
\let\originallongtable\longtable
\let\endoriginallongtable\endlongtable

% Enhanced longtable with auto-styling
\renewenvironment{longtable}[1]{%
    \resettablerows%
    \setlength{\arrayrulewidth}{0.5pt}%
    \arrayrulecolor{bordercolor}%
    \renewcommand{\arraystretch}{1.3}%
    \originallongtable{#1}%
}{%
    \endoriginallongtable%
}
% Define alternating row colors for all tables
% \rowcolors{2}{white}{lightgray}
% =============================================================================
% 

% Define colors for professional sections
\definecolor{sectionblue}{RGB}{25, 42, 86}
\definecolor{accentblue}{RGB}{70, 130, 180}
\definecolor{lightblue}{RGB}{230, 240, 250}
\definecolor{formulaback}{RGB}{248, 250, 252}

% Professional section styling

\titleformat{\section}
{\color{sectionblue}\Large\bfseries}
{\thesection}{1em}{}

% [\color{accentblue}\titlerule[0.8pt]]

\titleformat{\subsection}
{\color{sectionblue}\large\bfseries}
{\thesubsection}{1em}{}

% Enhanced list styling
\setlist[itemize,1]{
    leftmargin=1.5em,
    itemsep=0.5em,
    parsep=0.2em,
    topsep=0.5em,
    label=\textcolor{accentblue}{$\blacktriangleright$}
}

\setlist[itemize,2]{
    leftmargin=2em,
    itemsep=0.3em,
    parsep=0.1em,
    label=\textcolor{sectionblue}{$\circ$}
}

% Professional boxes for mathematical content
\newtcolorbox{mathconcept}[1]{
    colback=lightblue,
    colframe=accentblue,
    fonttitle=\bfseries\color{sectionblue},
    title=#1,
    rounded corners,
    boxrule=1pt,
    left=8pt,
    right=8pt,
    top=8pt,
    bottom=8pt
}

% Formula highlighting
\newcommand{\formula}[1]{%
    \colorbox{formulaback}{\ensuremath{#1}}%
}
\newcommand{\sectionbreak}{\clearpage} % inserts page break before each section

% \begin{document}
\mainmatter
% \clearpage
% \tableofcontents
% \clearpage
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries MATHEMATICS}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/maths.jpg}
\end{center}

\chapter{Essential Mathematical Techniques}%
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:maths}

\begin{itemize}
    \item \textbf{Modular Arithmetic:}
    \begin{itemize}
        \item $(a \pm b) \mod m = (a \mod m \pm b \mod m) \mod m$
        \item $(a \cdot b) \mod m = ((a \mod m) \cdot (b \mod m)) \mod m$
        \item Modular exponentiation: $a^b \mod m$ using binary exponentiation ($\mathcal{O}(\log b)$)
        \item Modular inverses using Fermat's little theorem ($a^{-1} \equiv a^{m-2} \pmod{m}$ for prime $m$)
    \end{itemize}
    
    \item \textbf{Prime Numbers:}
    \begin{itemize}
        \item Sieve of Eratosthenes ($\mathcal{O}(n \log \log n)$ for primes up to $n$
        \item Prime factorization via trial division ($\mathcal{O}(\sqrt{n})$)
        \item Miller-Rabin primality test (probabilistic, efficient for large numbers)
        \item Count of divisors and sum of divisors formulas from prime factors
    \end{itemize}
    
    \item \textbf{GCD \& LCM:}
    \begin{itemize}
        \item Euclidean algorithm: $\gcd(a,b) = \gcd(b, a \mod b)$
        \item $\gcd(a,b) \cdot lcm(a,b) = |a \cdot b|$
        \item Extended Euclidean algorithm for solving $ax + by = \gcd(a,b)$
    \end{itemize}
    
    \item \textbf{Combinatorics:}
    \begin{itemize}
        \item Precompute factorials and inverse factorials modulo $m$ ($\mathcal{O}(n)$)
        \item Combinations: $C(n,k) = \frac{n!}{k!(n-k)!}$; $C(n,k) = C(n-1,k-1) + C(n-1,k)$
        \item Lucas theorem for binomial coefficients modulo prime
        \item Stars and bars technique for non-negative integer solutions
    \end{itemize}
    
    \item \textbf{Number Theory:}
    \begin{itemize}
        \item Chinese Remainder Theorem (CRT) for solving system of congruences
        \item Euler's totient function: $\phi(n)$ and Euler's theorem $a^{\phi(m)} \equiv 1 \pmod{m}$ for $\gcd(a,m)=1$
        \item Wilson's theorem: $(p-1)! \equiv -1 \pmod{p}$ for prime $p$
    \end{itemize}
    
    \item \textbf{Binary Exponentiation:}
    \begin{itemize}
        \item Compute $a^n$ in $\mathcal{O}(\log n)$ time
        \item Matrix exponentiation for linear recurrences (e.g., Fibonacci in $\mathcal{O}(\log n)$)
        \item Apply to polynomials and transformations
    \end{itemize}
    
    \item \textbf{Game Theory:}
    \begin{itemize}
        \item Nim game: XOR of pile values ($\neq 0$ → winning position)
        \item Grundy numbers (mex function) for impartial games
        \item Sprague-Grundy theorem for composite games
    \end{itemize}
    
    \item \textbf{Series \& Sequences:}
    \begin{itemize}
        \item Arithmetic series: $S_n = \frac{n}{2}(2a + (n-1)d)$
        \item Geometric series: $S_n = a\frac{r^n-1}{r-1}$ ($r \neq 1$)
        \item Harmonic series: $H_n \approx \ln n + \gamma$ (Euler's constant)
        \item Faulhaber's formula for power sums $\sum k^p$
    \end{itemize}
    
    \item \textbf{Inequalities:}
    \begin{itemize}
        \item AM-GM inequality: $\frac{a_1+\cdots+a_n}{n} \geq \sqrt[n]{a_1 \cdots a_n}$
        \item Cauchy-Schwarz: $(\sum a_i b_i)^2 \leq (\sum a_i^2)(\sum b_i^2)$
        \item Chebyshev's inequality for monotonic sequences
    \end{itemize}
    
    \item \textbf{Probability \& Expectation:}
    \begin{itemize}
        \item Linearity of expectation: $E[X+Y] = E[X] + E[Y]$ even for dependent variables
        \item Geometric distribution: Expected trials until success $= \frac{1}{p}$
        \item Markov chains and absorbing states
    \end{itemize}
    
    \item \textbf{Geometry Formulas:}
    \begin{itemize}
        \item Shoelace formula for polygon area
        \item Pick's theorem: $A = I + B/2 - 1$ for lattice polygons
        \item Convex hull (Graham scan), line intersection, point-in-polygon
    \end{itemize}
    
    \item \textbf{Optimization Techniques:}
    \begin{itemize}
        \item Precomputation (sieve, factorials, prefix sums)
        \item Binary search on answer (monotonic functions)
        \item Two pointers technique for subarray problems
    \end{itemize}
    
    \item \textbf{Critical Edge Cases:}
    \begin{itemize}
        \item Integer overflow (use \texttt{long long} or modulo)
        \item Division by zero and negative modulo handling
        \item Floating point precision issues (use epsilon comparison)
        \item Boundary conditions (n=0, n=1, large inputs)
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Counting problems (combinatorics + modular arithmetic)
        \item Digit DP for number property queries
        \item Diophantine equations ($ax + by = c$)
        \item Multiplicative function properties ($\phi$, $\mu$, divisor functions) 


    \end{itemize}
\end{itemize}

\section{Mathematics-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead

Count Digits & $\mathcal{O}(\log_{10} N)$ & Divide number by 10 repeatedly. & Use $\lfloor \log_{10}N \rfloor + 1$ formula. & $N = 0$ (special case) \\
\hline
Palindrome Number & $\mathcal{O}(\log_{10} N)$ & Reverse number and compare with original. & Reverse half only to save time. & Negative numbers, numbers ending in 0 \\
\hline
Factorial of a Number & $\mathcal{O}(N)$ & Multiply from 1 to $N$ iteratively. & Use memoization if computed repeatedly. & Overflow for large $N$ \\
\hline
Trailing Zeros in Factorial & $\mathcal{O}(\log_5 N)$ & Count number of 5s in prime factorization. & Precompute for multiple queries. & $N < 5$ \\
\hline
GCD / HCF & $\mathcal{O}(\log \min(a,b))$ & Use Euclidean algorithm TC drivat. by fibonacci steps (increase by 1). & Use iterative form to avoid recursion stack. & $a=0$, $b=0$ \\
\hline
LCM of Two Numbers & $\mathcal{O}(\log \min(a,b))$ & $\text{LCM} = \frac{a \cdot b}{\text{GCD}}$ & Avoid overflow using $(a/\text{GCD}) \cdot b$ & One of them is 0 \\
\hline
Check for Prime & $\mathcal{O}(\sqrt{N})$ & Trial division up to $\sqrt{N}$ & Check only up to odd numbers and skip even & $N < 2$, very large $N$ \\
\hline
Prime Factors & $\mathcal{O}(\sqrt{N})$ & Divide repeatedly by prime numbers. & Use Sieve for multiple queries. & $N=1$, $N$ is prime \\
\hline
All Divisors of a Number & $\mathcal{O}(\sqrt{N})$ & Check all $i$ where $i \mid N$ and also $N/i$. & Store in a set to avoid duplicates. & Perfect square, $N=1$ \\
\hline
Sieve of Eratosthenes & $\mathcal{O}(N \log \log N)$ & Use boolean array to mark non-primes. & Skip even numbers to reduce space/time. & $N < 2$ \\
\hline
Computing Power ($a^b$) & $\mathcal{O}(\log b)$ & Use exponentiation by squaring. & Apply modulus if result is large. & $b=0$, $a=0$ \\
\hline
Modular Arithmetic & $\mathcal{O}(1)$ & Apply modulo rules: $(a \pm b)\%m$, etc. & Handle underflow: use $((a\%m)+m)\%m$ & Negative numbers, division mod \\
\hline
Iterative Power & $\mathcal{O}(\log b)$ & Binary exponentiation. & Use bitwise operations for speed. & $a=0$, $b=0$ \\
\hline

\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/maths}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries BIT-MANIPULATION}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/bits.png}
\end{center}
\chapter{Essential Bit Manipulation Techniques  }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:bits}
\begin{itemize}
    \item \textbf{Power of Two Check:}
    \begin{itemize}
        \item ${n \& (n-1) == 0 \&\& n != 0}$
        \item Clears least significant set bit (e.g., $8 \rightarrow 1000$, $7 \rightarrow 0111$)
    \end{itemize}
    
    \item \textbf{XOR Properties:}
    \begin{itemize}
        \item $a \oplus a = 0$, $a \oplus 0 = a$
        \item $a \oplus b = b \oplus a$ (commutative)
        \item $(a \oplus b) \oplus c = a \oplus (b \oplus c)$ (associative)
        \item Useful for finding missing numbers/canceling pairs
    \end{itemize}
    
    \item \textbf{Mask Operations:}
    \begin{itemize}
        \item Set $k$-th bit: \texttt{n | (1 << k)}
        \item Clear $k$-th bit: \texttt{n \& \textasciitilde(1 << k)}
        \item Toggle bit: \texttt{n \^{} (1 << k)}
        \item Check bit: \texttt{(n >> k) \& 1}
    \end{itemize}
    
    \item \textbf{Brian Kernighan's Algorithm:}
    \begin{itemize}
        \item Count set bits with \texttt{while (n) { count++; n \&= n-1; }}
        \item Complexity: $\mathcal{O}(\text{\# set bits})$ instead of $\mathcal{O}(n)$
    \end{itemize}
    
    \item \textbf{Rightmost Set Bit:}
    \begin{itemize}
        \item Isolate: \texttt{n \& -n} (using two's complement)
        \item Clear: \texttt{n \&= n-1}
    \end{itemize}
    
    \item \textbf{Swapping Without Temp:}
    \begin{itemize}
        \item \texttt{a \^{}= b; b \^{}= a; a \^{}= b;}
    \end{itemize}
    
    \item \textbf{Signed Shift vs Unsigned Shift:}
    \begin{itemize}
        \item Logical right shift (\texttt{>>>}): Fill with 0s
        \item Arithmetic right shift (\texttt{>>}): Preserve sign bit
    \end{itemize}
    
    \item \textbf{Subset Generation:}
    \begin{itemize}
        \item Power sets via bitmask: \texttt{for (int i=0; i < (1<<n); i++)}
        \item Extract elements: \texttt{if (i \& (1 << j))}
    \end{itemize}
    
    \item \textbf{Advanced Patterns:}
    \begin{itemize}
        \item XOR from 1 to $n$: Pattern repeats every 4 (mod 4)
        \item Swap adjacent bits: \texttt{((n \& 0xAAAAAAAA) >> 1) | ((n \& 0x55555555) << 1)}
        
        \item Reverse bits: Divide \& conquer with masks
    \end{itemize}
    
    \item \textbf{Optimization Tricks:}
    \begin{itemize}
        \item Precompute bit counts for small chunks (lookup table)
        \item Use integer as boolean array (bit sets)
        
        \item Parallel bit operations (e.g., count set bits with magic numbers)
    \end{itemize}
    
    \item \textbf{Critical Edge Cases:}
    \begin{itemize}
        \item Negative numbers (two's complement representation)
        \item Integer overflow in shifts (e.g., \texttt{1 << 31} in 32-bit)
        \item Shifting by $\geq$ bit width (undefined behavior)
        \item Zero handling (especially in power-of-two checks)
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Single Number (XOR all elements)
        \item Bitwise AND of number range (find common MSB prefix)
        \item Minimum Flips (XOR + count bits)
        \item Bitwise OR/AND subarrays (property observation)
    \end{itemize}
\end{itemize}
\section{Bit-Manipulation-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead

Check if Number is Power of 2 & $\mathcal{O}(1)$ & If $n > 0$ and $(n \& (n - 1)) == 0$, then it's a power of 2. & Avoid loop-based or recursive approaches. & $n = 0$, $n < 0$ (not valid inputs) \\
\hline

XOR of All Numbers from 1 to N & $\mathcal{O}(1)$ & Use pattern based on $n \mod 4$:  
$0 \Rightarrow n$,  
$1 \Rightarrow 1$,  
$2 \Rightarrow n+1$,  
$3 \Rightarrow 0$. & Use formula for large inputs or multiple queries. & Test with $n = 0$, $n = 1$ \\
\hline

Check if Kth Bit is Set & $\mathcal{O}(1)$ & Use $(n \& (1 \ll k))$ or $(n \gg k) \& 1$ to check. & Prefer bitwise operations over string conversions. & $k$ exceeds number of bits in $n$ \\
\hline

Count Set Bits & $\mathcal{O}(\log N)$ & Use Brian Kernighan's algorithm: repeatedly turn off the rightmost set bit. & Use lookup table (precomputed bits for 0–255) in repeated use. & $n = 0$ (has 0 set bits) \\
\hline
Convert Any Base to Any Base & $O(\log N)$ & Convert source → decimal → target base by repeated division & Handle fractional part separately for floating bases & Leading zeros, invalid chars \\
\hline
Floating Point Decimal to Binary & $O(\log I + F)$ & Convert integer normally; multiply fraction by 2 repeatedly for fractional part & Limit fractional precision to 32 bits max & Infinite fractions (e.g., 0.1) \\
\hline
Longest Sequence of 1s by One Bit Flip & $O(\log N)$ & Track current streaks of 1s and possible merge with one 0 in between & Store left, right streaks and merge via window & All 1s or all 0s \\
\hline
Pairwise Swap Bits in Integer & $O(1)$ & Swap even and odd bits using masks: ((n \& 0xAAAAAAAA) >> 1) | ((n \& 0x55555555) << 1) & Use 32-bit constants for masking & Small integers (e.g., < 4-bit) \\
\hline
Two Odd Occurring Numbers & $\mathcal{O}(n)$ & XOR all elements to get XOR of the two odd numbers, then use a set bit to divide into two groups. & Use rightmost set bit to split numbers efficiently. & All other numbers must appear even number of times \\
\hline

Power Set using Bitwise & $\mathcal{O}(2^n \cdot n)$ & Each subset can be generated by using bitmasks from 0 to $2^n - 1$. & Use bitmasking instead of recursion for simplicity. & Empty set, duplicate elements \\
\hline

Maximum AND Value of Pair in Array & $\mathcal{O}(n \log n)$ & Try fixing bits from MSB to LSB, keeping candidates that can satisfy AND condition. & Use filtering based on current mask during iteration. & All elements same or small values \\
\hline
Divide Two Integers using Bit Manipulation & $O(\log n)$ & Subtract shifted divisor (left shift until <= dividend), accumulate result & Handle negatives using sign variable & Overflow (INT\_MIN / -1) \\
\hline

\end{longtable}
\clearpage

\newgeometry{margin=1in}
\input{solutions/bits}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries ARRAYS}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/array.png}
\end{center}

\chapter{Essential Array Techniques  }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:arrays}
Most important step in arrays question is to think about all the different possible test cases that you can generate. Then observe them to see what pattern they are following.
\begin{itemize}[leftmargin=*]
    \item \textbf{Two Pointer Technique:}
    \begin{itemize}
        \item Same Direction Pointers: Use when you need to maintain a window or process elements sequentially
        \item Opposite Direction Pointers: Ideal for sorted arrays, palindrome checks, or pair sum problems
        \item Fast-Slow Pointers: Detect cycles, find middle elements, or remove duplicates
        \item Key Pattern: Always consider if you can reduce $O(n^2)$ to $O(n)$ using two pointers
    \end{itemize}
    
    \item \textbf{Sliding Window:}
    \begin{itemize}
        \item Fixed Size Window: When subarray/substring length is constant
        \item Variable Size Window: When you need to find optimal window based on conditions
        \item Shrinking Strategy: Expand right pointer first, then shrink left when condition violated
        \item Template: Maintain window state using hash maps or frequency arrays
        \item Positive,Negative,Zero : Containing arrays when to use $<=$ target
    \end{itemize}
    
    \item \textbf{Prefix Sum Techniques:}
    \begin{itemize}
        \item 1D Prefix Sum: $prefix[i] = prefix[i-1] + arr[i]$ for range sum queries
        \item 2D Prefix Sum: For matrix range sum queries in $O(1)$ time
        \item Prefix XOR: Useful for subarray XOR problems
        \item Hash Map + Prefix: Store prefix sums to find subarrays with target sum
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Monotonic Stack/Deque:}
    \begin{itemize}
        \item Next Greater Element: Maintain decreasing stack
        \item Largest Rectangle: Classic histogram problem using monotonic stack
        \item Sliding Window Maximum: Use monotonic deque for $O(n)$ solution
        \item Pattern Recognition: When you need to find next/previous greater/smaller elements
    \end{itemize}
    
    \item \textbf{Binary Search on Arrays:}
    \begin{itemize}
        \item Search Space: Identify the range where answer can exist
        \item Monotonic Property: Ensure the search space has a monotonic property
        \item Template: Use $left + (right - left) / 2$ to avoid overflow
        \item Edge Cases: Handle empty arrays, single elements, and boundary conditions
    \end{itemize}
    
    \item \textbf{Divide and Conquer:}
    \begin{itemize}
        \item Merge Sort Pattern: For inversion counting, smaller elements problems
        \item Quick Select: Finding kth element in $O(n)$ average time
        \item Maximum Subarray: Kadane's algorithm or divide-and-conquer approach
        \item Recurrence Relations: Master theorem for time complexity analysis
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Mathematical Insights:}
    \begin{itemize}
        \item Pigeonhole Principle: If $n+1$ elements in range $[1,n]$, at least one duplicate exists
        \item XOR Properties: $a \oplus a = 0$, $a \oplus 0 = a$, useful for finding unique elements
        \item Modular Arithmetic: Handle large numbers and cyclic patterns
        \item Dutch National Flag: Partition array into three parts efficiently
    \end{itemize}
    
    \item \textbf{Index Manipulation:}
    \begin{itemize}
        \item Negative Marking: Use array elements as indices, mark visited by negation
        \item Cyclic Sort: When array contains numbers in range $[1,n]$ or $[0,n-1]$
        \item Index as Hash: Use array positions as hash keys when range is limited
        \item In-place Algorithms: Modify array without extra space using clever indexing
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Subarray Problems:}
    \begin{itemize}
        \item Contiguous Elements: Use sliding window or two pointers
        \item Sum-based Conditions: Prefix sum + hash map approach
        \item Maximum/Minimum Subarray: Kadane's algorithm variants
        \item K-constraints: Often solvable with sliding window technique
    \end{itemize}
    
    \item \textbf{Frequency-based Problems:}
    \begin{itemize}
        \item Character/Number Frequency: Use hash maps or frequency arrays
        \item Anagram Detection: Sort strings or compare frequency maps
        \item Top K Elements: Use heap or quickselect algorithm
        \item Majority Element: Boyer-Moore voting algorithm for $O(1)$ space
    \end{itemize}
    
    \item \textbf{Sorting-based Solutions:}
    \begin{itemize}
        \item When to Sort: If relative order doesn't matter in final answer
        \item Custom Comparators: For complex sorting requirements
        \item Merge Intervals: Sort by start time, then merge overlapping
        \item Meeting Rooms: Sort intervals and check for conflicts
    \end{itemize}
\end{itemize}
\begin{itemize}[leftmargin=*]
    \item \textbf{Common Reductions:}
    \begin{itemize}
        \item $O(n^2) \rightarrow O(n)$: Use hash maps, two pointers, or sliding window
        \item $O(n^2) \rightarrow O(n \log n)$: Sort first, then use binary search or two pointers
        \item $O(n^3) \rightarrow O(n^2)$: Fix one variable, optimize the rest
        \item $O(n \log n) \rightarrow O(n)$: Use counting sort for limited range integers
    \end{itemize}
    
    \item \textbf{Space-Time Tradeoffs:}
    \begin{itemize}
        \item Memoization: Trade space for time in recursive solutions
        \item Hash Tables: $O(1)$ lookup at cost of $O(n)$ space
        \item In-place Modifications: Save space by modifying input array
        \item Bit Manipulation: Use bits to store multiple boolean flags (\textbf{All Unique Characters in string,Palindrome Permutation})
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Edge Cases to Consider:}
    \begin{itemize}
        \item Empty Array: Handle $n = 0$ case explicitly
        \item Single Element: Many algorithms need special handling for $n = 1$
        \item All Same Elements: Test with arrays containing identical elements
        \item Sorted/Reverse Sorted: Test with already sorted input
        \item Integer Overflow: Use long long for sum calculations
    \end{itemize}

    \item \textbf{Debugging Strategies:}
    \begin{itemize}
        \item Small Test Cases: Start with arrays of size 1-3
        \item Boundary Values: Test with minimum and maximum constraints
        \item Print Intermediate States: Debug by printing array states
        \item Invariant Checking: Verify loop invariants at each iteration
    \end{itemize}
\end{itemize}
\begin{itemize}[leftmargin=*]
    \item \textbf{Quick Implementation:}
    \begin{itemize}
        \item Template Preparation: Have pre-written templates for common patterns
        \item STL Mastery: Know \texttt{sort()}, \texttt{binary\_search()}, \texttt{lower\_bound()}, etc.
        \item Fast I/O: Use \texttt{ios\_base::sync\_with\_stdio(false)} for faster input
        \item Macro Usage: Define macros for frequently used code snippets
    \end{itemize}

    \item \textbf{Problem Analysis:}
    \begin{itemize}
        \item Constraint Analysis: Use constraints to determine expected time complexity
        \item Pattern Matching: Quickly identify if problem fits known patterns
        \item Simplified Version: Solve easier version first, then generalize
        \item Multiple Approaches: Think of brute force, then optimize step by step
    \end{itemize}
\end{itemize}

\section{Array-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead

Equilibrium Index of Array & $\mathcal{O}(n)$ & Calculate total sum, then iterate maintaining left sum and subtract current from total to get right sum. & Single-pass method using precomputed total sum. & All negative numbers, index at ends \\
\hline

Largest Sum Subarray (Kadane’s) & $\mathcal{O}(n)$ & Kadane’s Algorithm – track current and max sums. & Reset current sum when it drops below 0. & All negatives (return max element) \\
\hline

Merge Two Sorted Arrays & $\mathcal{O}(n + m)$ & Use two-pointer technique for merging. & Avoid extra space if merging into one array with space. & One array empty \\
\hline

Move Zeros to End & $\mathcal{O}(n)$ & Use two-pointer technique, swap non-zero elements forward. & Minimize swaps by checking index before swap. & All zeros or no zeros \\
\hline

Left Rotate Array by D Places & $\mathcal{O}(n)$ & Use reversal algorithm (reverse parts and full array). & Avoid multiple shifts with modulo $D \% n$. & $D > n$, $D = 0$ \\
\hline

Leaders in an Array & $\mathcal{O}(n)$ & Traverse from right, keep track of max seen so far. & No need to check all elements left of current. & All decreasing or increasing \\
\hline

Maximum Difference with Order & $\mathcal{O}(n)$ & Track minimum element seen so far, compute difference. & Only one pass needed using min till index. & No profit (return 0 or -1) \\
\hline

Frequencies in Sorted Array & $\mathcal{O}(n)$ & Traverse array and count frequency changes at each value. & Use binary search to find boundaries if needed. & Single element repeated \\
\hline

Stock Buy and Sell & $\mathcal{O}(n)$ & Buy at local minima, sell at next peak. Multiple transactions allowed. & Track ascending subarrays for profit. & No transaction possible \\
\hline

Maximum Circular Subarray Sum & $\mathcal{O}(n)$ & Use Kadane’s for normal max, and total sum - min subarray sum. & Handle all negative case separately. & All elements negative \\
\hline

Majority Element (Boyer-Moore) & $\mathcal{O}(n)$ & Boyer-Moore Voting Algorithm for candidate + verification. & Avoid hashmaps for optimal space. & No element appears $>$ n/2 \\
\hline

Trapping Rain Water & $\mathcal{O}(n)$ & Use two-pointer approach or precompute left/right max arrays. & Two-pointer method is space-efficient. & All increasing/decreasing \\
\hline

Minimum Consecutive Flips & $\mathcal{O}(n)$ & Count transitions and flip the smaller group. & Start from index 1 and track change points. & All same elements \\
\hline

Sliding Window Technique & $\mathcal{O}(n)$ & Maintain window sum/condition while expanding and shrinking bounds. & Reuse previous computations to update window. & k $>$ n, empty array \\
\hline
Consecutive Ones III & $O(n)$ & Sliding window with at most $k$ zeros allowed; shrink if count > k & Maintain left pointer for window & k = 0 or all 1s \\
\hline
Longest Substring with At Most K Distinct (Fruit in Basket) & $O(n)$ & Sliding window + hashmap of frequencies, shrink when map size > k & Use OrderedDict or default dict & k > distinct chars, k = 0 \\
\hline
Longest Substring Without Repeating Characters & $O(n)$ & Sliding window + set or map to track last seen index & Update left pointer when repeat found & All unique or all same \\
\hline
Binary Subarray With Sum = K & $O(n)$ & Prefix sum + hashmap count of sums: $count += freq[curr - k]$ & Use cumulative sum & Many zeros or k = 0 \\
\hline
Count All Substrings With Exactly K Distinct Chars & $O(n)$ & AtMost(K) - AtMost(K-1) using sliding window count logic & Reuse AtMost function for both & K = 0 or more than total distinct \\
\hline
Print All Substrings With Exactly K Distinct Chars & $O(n^2)$ & Iterate i from 0 to n-1, use freq map to expand j and print when distinct = k & Early break if distinct > k & Duplicates or repeated characters \\
\hline

Prefix Sum Technique & $\mathcal{O}(n)$ preprocess, $\mathcal{O}(1)$ query & Build prefix sum array to compute range sums in constant time. & Avoid recomputation of sums. & First index access, empty ranges \\
\hline

Maximum Appearing Element in Ranges & $\mathcal{O}(N + max(R))$ & Use difference array to mark increments/decrements, prefix sum to find max value. & Avoid brute force by using diff array instead of actual marking. & Multiple same max values (pick smallest index) \\
\hline

Subarray with Given Sum Count/Find. Also can find length of longest such & $\mathcal{O}(n)$ & Use sliding window for positive integers: expand until target $>=$ sum, then shrink. & Only works for positive integers for negatives go for hashing. & No valid subarray, single element solution \\
\hline
Next Permutation & $O(n)$ & Find longest non-increasing suffix, swap pivot with next larger, reverse suffix & Use STL next\_permutation if allowed & Last permutation → return first \\
\hline
Maximum Product Subarray & $O(n)$ & Two variables tracking prefix and suffix product max of them at any instance & Track current max and min due to negative flips: $max = \max(arr[i], arr[i] \cdot max, arr[i] \cdot min)$  Reset on zero & Negative numbers, multiple zeros \\
\hline
Find Rotation Count (Sorted \& Rotated Array) & $O(\log n)$ & Binary search for minimum element index & Compare with mid and neighbors & No rotation → return 0 \\
\hline
Minimum Window Substring & $O(|s|+|t|)$ & Sliding-window with two frequency maps (need/window), expand right until all required chars are met then contract left to minimize & Use a fixed‐size array (e.g. size 128) instead of dicts for ASCII‐only input; pre‐filter s to chars in t & Return "" if t is empty, longer than s, or no valid window \\
\hline
Convert Array to Peak-Valley & $O(n)$ & Traverse and ensure A[i] < A[i+1] > A[i+2] pattern alternately & Swap adjacent pairs accordingly & Already peak/valley \\
\hline
Find Duplicate (N=32000, 4KB mem) & $O(n)$ & Use BitSet of 32000 bits (4KB) and mark each number & Implement BitSet via byte array & Repeating elements \\
\hline
Find Missing Int (4B Numbers, 1GB RAM) & $O(n)$ & Use 2-pass: divide space into blocks, count per block, then bit array in one block & 1st pass: count ranges, 2nd: locate missing bit & Multiple missing numbers \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/arrays}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries SEARCHES}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/search.png}
\end{center}

\chapter{Essential Binary Search Techniques  }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:search}
\begin{itemize}
    \item \textbf{Standard Binary Search Pattern:}
    \begin{itemize}
        \item Initialize \texttt{left} and \texttt{right} boundaries
        \item While \texttt{left <= right}: 
        \item \quad Calculate \texttt{mid = left + (right - left) // 2} (prevents overflow)
        \item \quad Three-way comparison: 
        \begin{itemize}
            \item Equal: return \texttt{mid}
            \item Target $<$ \texttt{arr[mid]}: \texttt{right = mid - 1}
            \item Target $>$ \texttt{arr[mid]}: \texttt{left = mid + 1}
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Search Space Selection:}
    \begin{itemize}
        \item Sorted arrays (obvious case)
        \item Answer prediction: When answer space is monotonic (min/max problems)
        \item Function domains: Where f(x) transitions from false to true
    \end{itemize}
    
    \item \textbf{Lower/Upper Bound Variants:}
    \begin{itemize}
        \item First occurrence: When \texttt{arr[mid] == target}, set \texttt{right = mid - 1}
        \item Last occurrence: When \texttt{arr[mid] == target}, set \texttt{left = mid + 1}
        \item Floor: Largest element $\leq$ target
        \item Ceil: Smallest element $\geq$ target
    \end{itemize}
    
    \item \textbf{Rotated Array Searches:}
    \begin{itemize}
        \item Find pivot: Compare \texttt{arr[mid]} with \texttt{arr[0]} or \texttt{arr[high]}
        \item Two-pass: Find pivot then binary search in segment
        \item Single-pass: Check which segment is sorted
    \end{itemize}
    
    \item \textbf{Matrix Searches:}
    \begin{itemize}
        \item Row-sorted + column-sorted: Start from top-right corner
        \item Convert 2D to 1D: \texttt{mid} to \texttt{(mid//cols, mid\%cols)}
        \item Find k-th smallest: Binary search on value range
    \end{itemize}
    
    \item \textbf{Answer Prediction Patterns:}
    \begin{itemize}
        \item Minimize maximum: "Split array largest sum", "ship packages"
        \item Maximize minimum: "Aggressive cows", "max distance to gas station"
        \item Condition-based: First value where condition becomes true
    \end{itemize}
    
    \item \textbf{Bitonic Array Searches:}
    \begin{itemize}
        \item Find peak: Compare \texttt{arr[mid]} with neighbors
        \item Ascending segment: Standard binary search
        \item Descending segment: Reverse binary search logic
    \end{itemize}
    
    \item \textbf{Advanced Applications:}
    \begin{itemize}
        \item Real number domains: Precision handling with tolerance
        \item Binary search on function: Square root, monotonic functions
        \item Exponential search: For unbounded arrays
    \end{itemize}
    
    \item \textbf{Decision Function Design:}
    \begin{itemize}
        \item Must be monotonic: \texttt{f(x)} transitions once from false to true
        \item Efficient implementation: O(n) or better
        \item Parameterization: Often requires additional parameters (k, limit)
    \end{itemize}
    
    \item \textbf{Termination Conditions:}
    \begin{itemize}
        \item Standard: \texttt{while (left <= right)}
        \item Alternative: \texttt{while (left < right)} with \texttt{left = mid + 1} or \texttt{right = mid}
        \item Exact match vs. closest value
    \end{itemize}
    
    \item \textbf{Edge Cases:}
    \begin{itemize}
        \item Empty arrays
        \item Single-element arrays
        \item All elements equal
        \item Target outside range
        \item Duplicate elements
        \item Integer overflow in \texttt{mid} calculation
    \end{itemize}
    
    \item \textbf{Optimization Tricks:}
    \begin{itemize}
        \item Precomputation: For decision functions
        \item Early termination: When possible
        \item Two-layer binary search: Value + position
        \item Sanity checks: Before starting search
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Search in infinite stream: Exponential + binary search
        \item Find missing element: Compare index vs value
        \item Find rotation count: Pivot index
        \item Find peak element: Local maxima
    \end{itemize}
    
    \item \textbf{Debugging Tips:}
    \begin{itemize}
        \item Print \texttt{left/mid/right} values
        \item Check loop invariants
        \item Test with small cases (n=0,1,2,3)
        \item Verify decision function logic
    \end{itemize}
    
    \item \textbf{Alternative Implementations:}
    \begin{itemize}
        \item Bisect module in Python
        \item \texttt{std::lower\_bound} in C++
        \item \texttt{Arrays.binarySearch} in Java
        \item Custom comparators
    \end{itemize}
\end{itemize}
\section{Search-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
\hline
Ternary Search & $\mathcal{O}(\log n)$ & Divide range in 3 parts, recursively reduce search space. & Prefer over binary only in unimodal functions. & Non-unimodal function \\
\hline
Jump Search & $\mathcal{O}(\sqrt{n})$ & Jump by fixed step, then linear search in block. & Best for uniformly distributed sorted data. & Element near start or end \\
\hline
Missing and Repeating Number & $\mathcal{O}(n)$ & Use sum and sum of squares formula to derive two equations and solve for missing and repeating. & Use integer overflow-safe formulas or XOR-based approach. & Duplicates at start/end, all same elements \\
\hline
Find Peak Element in Unsorted Array & $\mathcal{O}(\log n)$ & Apply binary search: if mid $>$ neighbors, it's a peak, else move in direction of greater neighbor. & Avoid linear scan by using binary search. & Peak at boundaries, flat plateau \\
\hline
Search in an Infinite Sized Array & $\mathcal{O}(\log n)$ & Exponentially expand range until element $>$ target, then binary search in found range. & Start with small window and double size to minimize search space. & Very large target, target not present \\
\hline
Median of Two Sorted Arrays & $\mathcal{O}(\log \min(n, m))$ & Binary search on smaller array to partition both arrays at correct position. & Always binary search on smaller array to ensure log(min(n,m)). & Odd total length, one array empty \\
\hline

Search in Sorted Rotated Array & $\mathcal{O}(\log n)$ but $\mathcal{O}(n)$ for duplicates & Modified binary search: identify sorted half, move accordingly. & For same low, mid, high keep l++,h-- until not equal. & Rotation at 0 or n-1, duplicates at low,mid,high (for generalized) \\
\hline
Find Triplet with Given Sum (sorted) & $\mathcal{O}(n^2)$ & Fix one element and apply two-pointer approach on the rest. & Sort array once before outer loop. & No triplet found, multiple same triplets \\
\hline
One Repeating Element in Array from 1 to N (size N) & $\mathcal{O}(n)$ & Use Floyd’s Cycle Detection or array marking. & Prefer Floyd’s for O(1) space. & Repetition at start or end, minimal repeat count \\
\hline
One Repeating Element in Array from 1 to N (size N) & $\mathcal{O}(n)$ & Take $\Sigma n - \Sigma a[i] -eq(i) \space \& \space  
\Sigma n^2 - \Sigma a[i]^2 - eq(ii)$. & $Xor(a[i]) with Xor(1 .. n)$ then find different bit and proceed like 2 odd appearing. & Repetition at start or end, minimal repeat count \\
\hline
Multiple Repeating Elements in Array from 1 to N (size N) & $\mathcal{O}(n)$ & Use frequency count or mark visited indices using negation or add N. & Use modulo trick to track frequency in-place. & All elements same, no repetition \\
\hline
Allocate Minimum Pages(Similiar to Painter's partition or Split subarray minimum largest sum) & $O(n \cdot \log(sum(pages)$ & Binary search on answer in range max\_element to sum(array)+ greedy check if allocation is feasible with mid pages & Minimize max load among partitions & Pages $>$ total or students $>$ books \\
\hline
Minimum Days to Make $n$ Bouquets & $O(n \log D)$ & Binary search on days; check if $\geq n$ bouquets possible by checking $k$ adjacent bloom days $\leq mid$ & Greedy simulation inside binary search & Not enough flowers \\
\hline
Capacity to Ship Packages in D Days & $O(n \log \sum)$ & Binary search on capacity; check if packages can be shipped within $D$ days & Use greedy validation per capacity guess & Package weight > mid \\
\hline
Aggressive Cows & $O(n \log d)$ & Binary search on distance; place cows greedily with min gap $\geq mid$ & Sort stalls before processing & Only one cow or all cows = stalls \\
\hline
Kth Missing Positive Number & $O(\log n)$ & Binary search: $arr[i] - i - 1$ gives count of missing up to $i$ & Use linear scan if $n$ small & k before first element \\
\hline
Kth Element in Two Sorted Arrays & $O(\log \min(n, m))$ & Partition both arrays such that left parts have $k$ elements; binary search on smaller array & Handle all partition edge cases (0, n) & k = 1 or k = total length \\
\hline
Longest Repeating Substring (Binary Search) & $O(n \log n)$ & Binary search on length + rolling hash/set to check duplicates & Rabin-Karp-style hashing or Trie for checking repetition & Same substrings at different positions \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/binary_search}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries MATRIX}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/matrix.png}
\end{center}

\chapter{Essential Matrix Techniques  }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:matrix}
\begin{itemize}
    \item \textbf{Matrix Traversal Fundamentals:}
    \begin{itemize}
        \item Directions handling: Define \texttt{dirs = [(0,1), (1,0), (0,-1), (-1,0)]} for 4-way, add diagonals for 8-way
        \item Boundary checks: Verify \texttt{0 <= x < m} and \texttt{0 <= y < n} before accessing
        \item Visited tracking: Use visited matrix or in-place modification (mark as \#' or \texttt{-1})
    \end{itemize}
    
    \item \textbf{Breadth-First Search (BFS) Patterns:}
    \begin{itemize}
        \item Shortest path in unweighted grid:
        \begin{itemize}
            \item Multi-source BFS: Initialize queue with all starting points (e.g., rotting oranges)
            \item Layer tracking: Use queue size for level-order traversal
        \end{itemize}
        \item Flood fill variants: 
        \begin{itemize}
            \item Connected component counting (islands)
            \item Boundary detection (enclosed regions)
        \end{itemize}
        \item Optimization: 
        \begin{itemize}
            \item Bidirectional BFS for single-target paths
            \item Early termination when target found
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Depth-First Search (DFS) \& Recursion:}
    \begin{itemize}
        \item Connected components: 
        \begin{itemize}
            \item Standard DFS: Mark visited during recursion
            \item Count size/mark islands
        \end{itemize}
        \item Pathfinding with backtracking: 
        \begin{itemize}
            \item Explore all paths (rat in a maze)
            \item Prune invalid paths early
        \end{itemize}
        \item Cycle detection: 
        \begin{itemize}
            \item Track recursion stack with \texttt{visiting} state
            \item Detect in directed graphs (dependency matrices)
        \end{itemize}
        \item Optimization:
        \begin{itemize}
            \item Memoization: Cache states when possible
            \item Iterative DFS to avoid stack overflow
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Dynamic Programming on Matrices:}
    \begin{itemize}
        \item Path counting: 
        \begin{itemize}
            \item \texttt{dp[i][j] = dp[i-1][j] + dp[i][j-1]} (right/down moves)
            \item Handle obstacles: Set \texttt{dp[i][j] = 0} at blocked cells
        \end{itemize}
        \item Minimum path sum: 
        \begin{itemize}
            \item \texttt{dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]}
            \item Space optimization: Use 1D array or two rows
        \end{itemize}
        \item Submatrix problems: 
        \begin{itemize}
            \item Maximal square: \texttt{dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1}
            \item Largest rectangle: Combine with histogram method
        \end{itemize}
        \item State machine DP: 
        \begin{itemize}
            \item Cherry pickup: 3D DP \texttt{(r1, c1, r2)} since \texttt{c2 = r1 + c1 - r2}
            \item K moves/costs: Add extra dimension
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Advanced Traversal Techniques:}
    \begin{itemize}
        \item Spiral order: 
        \begin{itemize}
            \item Layer-by-layer: Use \texttt{top, bottom, left, right} boundaries
            \item Direction flipping: Simulate with direction vector
        \end{itemize}
        \item Diagonal traversal: 
        \begin{itemize}
            \item Sum property: \texttt{i + j = constant} (main), \texttt{i - j = constant} (anti-diagonal)
            \item Zigzag: Reverse every other diagonal
        \end{itemize}
        \item Rotation \& transformation: 
        \begin{itemize}
            \item Transpose: \texttt{mat[i][j] = mat[j][i]}
            \item Clockwise: Transpose + reverse rows
            \item Counter-clockwise: Transpose + reverse columns
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Word search: DFS with backtracking (prune at mismatches)
        \item Surrounded regions: Boundary DFS to mark safe 'O's
        \item Pacific-Atlantic flow: Multi-source BFS from both oceans
        \item Game boards (tic-tac-toe): Check all rows/cols/diagonals
        \item Matrix chain multiplication: Diagonal DP traversal
    \end{itemize}
    
    \item \textbf{Optimization Strategies:}
    \begin{itemize}
        \item In-place modification: 
        \begin{itemize}
            \item Use special values (\texttt{-1}, \texttt{0}, \texttt{2}) to preserve state
            \item Bitmasking for multiple states in integer matrix
        \end{itemize}
        \item Precomputation: 
        \begin{itemize}
            \item Row/column prefix sums for submatrix sums
            \item Nearest obstacle distance using multi-pass DP
        \end{itemize}
        \item Space-time tradeoffs: 
        \begin{itemize}
            \item Reduce DP dimensions based on dependencies
            \item Store only relevant previous states
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Critical Edge Cases:}
    \begin{itemize}
        \item 1x1 matrices (single cell)
        \item Empty matrix (0 rows or 0 columns)
        \item All cells blocked or all open
        \item Large matrices (stack overflow in DFS)
        \item Paths with dead-ends
        \item Negative values in DP paths
    \end{itemize}
    
    \item \textbf{Hybrid Techniques:}
    \begin{itemize}
        \item BFS + DP: 
        \begin{itemize}
            \item Shortest path with state (keys, collected items)
            \item Use bitmask to represent state
        \end{itemize}
        \item DFS + Memoization: 
        \begin{itemize}
            \item Top-down DP for path counting with constraints
            \item State = \texttt{(i, j, steps, ...)}
        \end{itemize}
        \item Multi-source BFS + DP: 
        \begin{itemize}
            \item Compute distance to nearest gate/obstacle
            \item Propagate distances simultaneously
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Debugging Tips:}
    \begin{itemize}
        \item Visualize small matrices (3x3)
        \item Print DP table after each row
        \item Check boundary conditions
        \item Verify visited marking logic
        \item Test symmetric and asymmetric cases
    \end{itemize}
\end{itemize}
\section{Matrix-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Matrix Rotation (90° Clockwise) & $\mathcal{O}(n^2)$ & Transpose the matrix, then reverse each row. & In-place rotation without extra matrix. & Non-square matrices (for generalized case) \\
\hline
Zero Matrix (Set Matrix Zeroes) & $O(n \cdot m)$ & First pass to mark rows and cols (can use first row/col as marker), second pass to set zeroes. & Use flags to remember if first row/col need to be zeroed. & Zero at (0,0), all elements zero, only one zero \\
\hline
Spiral Traversal of Matrix & $\mathcal{O}(n \cdot m)$ & Use boundary variables (top, bottom, left, right) and traverse in layers. & Use visited markers for irregular shapes.(Can also use dx[] and dy[]) & Single row/column matrix \\
\hline

Median of Row Wise Sorted Matrix & $\mathcal{O}(r \cdot \log(max - min) \cdot \log(c))$ & Binary search on value domain(min to max), count elements $<=$ mid in each row. & Use upper bound in each row for fast counting. & Repeated elements, odd number of total elements \\
\hline
Search in Row-wise and Column-wise Sorted Matrix & $\mathcal{O}(n + m)$ & Start from top-right or bottom-left and move logically. & Eliminate one row or column per step. & Element not present, smallest/largest at corners \\
\hline
Determinant of a Matrix & $\mathcal{O}(n^3)$ & Use Laplace expansion (naïve) or row reduction (Gaussian Elimination). & Prefer row-reduction for large matrices. & Zero row/column, singular matrix (det=0) \\
\hline
Search in Row-wise Sorted Matrix & $O(n + m)$ & Visualize as 1D array with two pointer on 0 and row*col -1 & Avoid full row/col scans just adjust mid and compare with l and r & Not found, duplicates \\
\hline
Peak Element in 2D Matrix & $O(n \log m)$ & Binary search on mid-column, find max in col, move to larger side & Apply on columns (or rows) alternately & Multiple peaks \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/matrix}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries SORTING}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/sort.png}
\end{center}

\chapter{Essential Sorting Techniques }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:sorting}
\begin{itemize}
    \item \textbf{Core Sorting Properties:}
    \begin{itemize}
        \item Stability: Preserves order of equal elements (Crucial for multi-key sorts)
        \item Adaptivity: Performs better on partially sorted data (Insertion sort)
        \item In-place: $O(1)$ extra space (Quicksort, Heapsort)
        \item Comparison vs Non-comparison: 
        \begin{itemize}
            \item Comparison: $\Omega(n \log n)$ lower bound
            \item Non-comparison: $O(n)$ possible (Counting, Radix)
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Algorithm Selection Guide:}
    \begin{itemize}
        \item Small arrays ($n \leq 50$): Insertion sort
        \item General purpose: Quicksort (average $O(n \log n)$), Mergesort (stable $O(n \log n)$)
        \item External sorting: Mergesort (disk-friendly)
        \item Integer sorting: 
        \begin{itemize}
            \item Limited range: Counting sort ($O(n + k)$)
            \item Large range: Radix sort ($O(d(n + b))$)
        \end{itemize}
        \item In-place required: Heapsort ($O(1)$ space)
    \end{itemize}
    
    \item \textbf{Custom Comparator Techniques:}
    \begin{itemize}
        \item Multi-key sorting:
        \begin{itemize}
            \item Primary, secondary keys: \texttt{return (a.p == b.p) ? a.q < b.q : a.p < b.p}
        \end{itemize}
        \item Reverse sorting: \texttt{return a > b} (descending)
        \item Absolute value sort: \texttt{return abs(a) < abs(b)}
        \item Custom objects: Define \texttt{operator<} or comparator function
    \end{itemize}
    
    \item \textbf{Advanced Sorting Patterns:}
    \begin{itemize}
        \item Inversion counting:
        \begin{itemize}
            \item Modified mergesort: Count during merge
            \item Applications: Similarity analysis, array disorder measure
        \end{itemize}
        \item K-sorted arrays:
        \begin{itemize}
            \item Heap sort: Min-heap of size $k+1$ ($O(n \log k)$)
            \item Insertion sort: $O(nk)$ for small $k$
        \end{itemize}
        \item Partial sorting:
        \begin{itemize}
            \item Quickselect: $O(n)$ for kth smallest
            \item Partial heapsort: Build heap of size k ($O(n + k \log n)$)
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Counting Sort Optimization:}
    \begin{itemize}
        \item Negative numbers: Shift range to non-negative
        \item Prefix sum array: Calculate output positions
        \item Stability: Process input right-to-left
        \item Character sorting: ASCII values as indices
    \end{itemize}
    
    \item \textbf{Radix Sort Techniques:}
    \begin{itemize}
        \item LSD (Least Significant Digit):
        \begin{itemize}
            \item Fixed-length keys: Numbers, fixed-width strings
            \item Stable sort per digit (usually counting sort)
        \end{itemize}
        \item MSD (Most Significant Digit):
        \begin{itemize}
            \item Variable-length keys: Strings, integers
            \item Recursive bucket sort
        \end{itemize}
        \item Base selection: Power-of-two bases for bitwise optimization
    \end{itemize}
    
    \item \textbf{Hybrid Sorting Approaches:}
    \begin{itemize}
        \item Introsort:
        \begin{itemize}
            \item Quicksort + Heapsort fallback + Insertion sort small arrays
            \item Prevents $O(n^2)$ worst-case
        \end{itemize}
        \item Timsort:
        \begin{itemize}
            \item Mergesort + Insertion sort + Run detection
            \item Python, Java default sort
        \end{itemize}
        \item Bucket sort + Sub-sort:
        \begin{itemize}
            \item Uniformly distributed data
            \item Sort buckets with appropriate algorithm
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Sorting Applications:}
    \begin{itemize}
        \item Two-pointer techniques:
        \begin{itemize}
            \item Two-sum: Sort + left/right pointers
            \item Remove duplicates: Sort + adjacent check
        \end{itemize}
        \item Greedy algorithms:
        \begin{itemize}
            \item Interval scheduling: Sort by finish time
            \item Fractional knapsack: Sort by value/weight ratio
        \end{itemize}
        \item Efficient searching:
        \begin{itemize}
            \item Binary search precondition
            \item Range queries: Sort + binary search
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Edge Cases \& Pitfalls:}
    \begin{itemize}
        \item Empty arrays: Always check size
        \item Single-element arrays: Trivial sort
        \item Duplicate elements: Stability matters
        \item Already sorted/reverse sorted: Test adaptive sorts
        \item Integer overflow: In comparator ($a - b$ fails for large values)
        \item Floating point: Special NaN handling
    \end{itemize}
    
    \item \textbf{Optimization Strategies:}
    \begin{itemize}
        \item Precomputation:
        \begin{itemize}
            \item Compute keys before sorting
            \item Schwartzian transform: Decorate-sort-undecorate
        \end{itemize}
        \item Lazy sorting:
        \begin{itemize}
            \item Partial sorts when possible
            \item Heap-based selection
        \end{itemize}
        \item Parallelization:
        \begin{itemize}
            \item Merge sort: Parallel merges
            \item Quick sort: Parallel partitions
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Largest number formed: Custom string comparator \texttt{(a+b) > (b+a)}
        \item Meeting rooms: Sort intervals by start time
        \item H-index: Sort citations + find $h$ where $h$ papers have $\geq h$ citations
        \item Merge intervals: Sort by start + merge adjacent
        \item Minimum absolute difference: Sort + adjacent difference
    \end{itemize}
    
    \item \textbf{Language-Specific Nuances:}
    \begin{itemize}
        \item C++:
        \begin{itemize}
            \item \texttt{std::sort}: Introsort, unstable for primitives
            \item \texttt{std::stable\_sort}: Mergesort variant
        \end{itemize}
        \item Java:
        \begin{itemize}
            \item \texttt{Arrays.sort}: Timsort (objects), Dual-Pivot Quicksort (primitives)
            \item Beware: Primitive sort unstable, object sort stable
        \end{itemize}
        \item Python:
        \begin{itemize}
            \item \texttt{list.sort()} and \texttt{sorted()}: Timsort, stable
            \item Key functions: \texttt{key=lambda x: (x[0], -x[1])}
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Debugging \& Testing:}
    \begin{itemize}
        \item Verify stability with duplicate keys
        \item Test with reverse-sorted input
        \item Check corner cases: min/max values, all equal
        \item Validate custom comparators:
        \begin{itemize}
            \item Anti-symmetry: $\text{comp}(a,b) \implies !\text{comp}(b,a)$
            \item Transitivity: $\text{comp}(a,b) \land \text{comp}(b,c) \implies \text{comp}(a,c)$
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Non-comparison Sort Limitations:}
    \begin{itemize}
        \item Counting sort: Integer keys in limited range
        \item Radix sort: Fixed-length keys or strings
        \item Bucket sort: Uniform distribution required
        \item Not applicable for arbitrary comparison functions
    \end{itemize}
\end{itemize}
\section{Sorting-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead
\hline
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Insertion Sort & $\mathcal{O}(n^2)$ & Insert elements into sorted part by shifting. & Adaptive for nearly sorted arrays. & All elements same, reverse sorted \\
\hline
Bubble Sort & $\mathcal{O}(n^2)$ & Repeatedly swap adjacent elements if out of order. & Use flag to detect sorted pass. & Already sorted array \\
\hline
Selection Sort & $\mathcal{O}(n^2)$ & Select min element and place at front. & Simple, not adaptive or stable. & All elements same \\
\hline
Merge Function (Merge Sort) & $\mathcal{O}(n)$ & Merge two sorted arrays using two pointers. & Extra array needed for merging. & Arrays of unequal sizes \\
\hline
Merge Sort & $\mathcal{O}(n \log n)$ & Divide and recursively merge sorted halves. & Stable sort, good for linked lists. & Already sorted array \\
\hline
Count Inversions in Array & $\mathcal{O}(n \log n)$ & Modified merge sort counting during merge. & Count inversions while merging. & All elements equal, reverse sorted \\
\hline
Partitioning of Array (Lomuto/Hoare) & $\mathcal{O}(n)$ & Rearrange elements around pivot. & Lomuto simpler, Hoare more efficient. & All elements same, pivot at extremes \\
\hline
Quick Sort & Avg: $\mathcal{O}(n \log n)$, Worst: $\mathcal{O}(n^2)$ & Partition and recursively sort sides. & Use random pivot to avoid worst case. & Already sorted or all same elements \\
\hline
Cycle Sort & $\mathcal{O}(n^2)$ & Place elements at correct index by cyclic swaps. & Minimum number of writes. & Duplicates need special care \\
\hline
Heap Sort & $\mathcal{O}(n \log n)$ & Build max-heap, extract max repeatedly. & In-place, not stable. & All elements equal \\
\hline
Counting Sort & $\mathcal{O}(n + k)$ & Count occurrences and compute prefix sum. & Only for small range of integers. & Large value range breaks efficiency \\
\hline
Radix Sort & $\mathcal{O}(n \cdot d)$ & Sort digits using stable sort (e.g., counting). & Works best when digits are bounded. & Very large digits/strings \\
\hline
Bucket Sort & $\mathcal{O}(n + k)$ & Distribute into buckets, then sort each. & Ideal when input is uniformly distributed. & All elements in one bucket \\
\hline
Kth Smallest Element in Array & $\mathcal{O}(n)$ avg & Use Quickselect (partition logic). & Random pivot gives linear avg. & k = 1 or n, duplicates \\
\hline
Chocolate Distribution (Min Diff) & $\mathcal{O}(n \log n)$ & Sort and find min diff of subarrays of size m. & Only sort once and slide window. & m $>$ n, all equal elements \\
\hline
Sort 3 Types of Elements & $\mathcal{O}(n)$ & Dutch National Flag algorithm: 3 pointers. & Single pass with constant space. & All same elements \\
\hline
Merge Overlapping Intervals & $\mathcal{O}(n \log n)$ & Sort by start time, merge if overlap. & Use list/stack to store merged. & Fully nested or same intervals \\
\hline
Meeting Maximum Guests & $\mathcal{O}(n \log n)$ & Sort arrivals and departures, use two pointers. & Keep track of current guests with max. & Overlapping times, same time arrival/departure \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/sorting}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries HASHING}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/hashing.png}
\end{center}

\chapter{Essential Hashing Techniques }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:hashing}
\begin{itemize}
    \item \textbf{Hash Function Fundamentals:}
    \begin{itemize}
        \item Integer hashing:
        \begin{itemize}
            \item Identity: $h(x) = x$ (for small bounded integers)
            \item Modulo: $h(x) = x \mod M$ (choose prime $M >$ max elements)
        \end{itemize}
        \item String hashing:
        \begin{itemize}
            \item Polynomial rolling hash: $H(s) = \sum_{i=0}^{n-1} s[i] \cdot p^i \mod M$
            \item Double hashing: Use two different $(p, M)$ pairs for collision safety
            \item Base selection: $p > $ alphabet size, typically 31, 53, or 131
        \end{itemize}
        \item Tuple hashing:
        \begin{itemize}
            \item Combine individual hashes: $h(a,b) = h(a) \oplus (h(b) \ll 1)$ 
            \item Boost method: $hash\_combine(seed, value)$ with bit mixing
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Collision Handling Strategies:}
    \begin{itemize}
        \item Separate chaining: Buckets with linked lists
        \item Open addressing:
        \begin{itemize}
            \item Linear probing: $h(x) + i \mod M$
            \item Quadratic probing: $h(x) + c_1 i + c_2 i^2 \mod M$
            \item Double hashing: $h_1(x) + i \cdot h_2(x) \mod M$
        \end{itemize}
        \item Load factor management: Rehash when $\alpha > 0.7$
    \end{itemize}
    
    \item \textbf{Common Hash-Based Data Structures:}
    \begin{itemize}
        \item Frequency counter: 
        \begin{itemize}
            \item Detect duplicates/anagrams: \texttt{unordered\_map<char, int>}
            \item Sliding window character counts
        \end{itemize}
        \item HashSet operations:
        \begin{itemize}
            \item $O(1)$ membership tests
            \item Union/intersection/difference operations
        \end{itemize}
        \item Prefix hash map:
        \begin{itemize}
            \item Subarray sum equals K: Store cumulative sums
            \item Two-sum variants: Store complements
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Advanced Hashing Patterns:}
    \begin{itemize}
        \item Rabin-Karp string search:
        \begin{itemize}
            \item Rolling hash for substring matching $O(n)$
            \item Update: $H_{new} = (H_{old} - s[i] \cdot p^{L-1}) \cdot p + s[i+L]$
        \end{itemize}
        \item Count-Min Sketch:
        \begin{itemize}
            \item Frequency estimation in streams with multiple hash functions
        \end{itemize}
        \item Bloom filters:
        \begin{itemize}
            \item Space-efficient probabilistic membership test
            \item False positives possible, no false negatives
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Key Optimization Techniques:}
    \begin{itemize}
        \item Precomputation:
        \begin{itemize}
            \item Precompute powers for rolling hash $O(n)$
            \item Precompute prefix hashes for strings
        \end{itemize}
        \item Custom hash functions:
        \begin{itemize}
            \item For user-defined types in C++: specialize \texttt{std::hash}
            \item Avoid systematic collisions with random seeds
        \end{itemize}
        \item Lazy deletion: Mark deleted slots instead of rehashing
    \end{itemize}
    
    \item \textbf{Multi-dimensional Hashing:}
    \begin{itemize}
        \item Grid hashing:
        \begin{itemize}
            \item $H(G) = \sum_{i,j} G[i][j] \cdot p_1^i \cdot p_2^j \mod M$
            \item Subgrid detection with 2D prefix hashes
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Edge Cases \& Pitfalls:}
    \begin{itemize}
        \item Integer overflow: Use modulo arithmetic consistently
        \item Negative modulo: $(x \mod M + M) \mod M$
        \item Empty collections: Hash of empty set should be non-zero
        \item Floating point keys: Avoid direct hashing of floats
        \item Mutable keys: Changing keys after insertion corrupts structure
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Anagram groups: Sort string or use frequency hash
        \item Subarray sum equals K: Prefix sum + hashmap
        \item Duplicate detection: HashSet for $O(1)$ lookups
        \item Longest substring without repeating chars: Sliding window + char map
        \item Two-sum variants: Store seen elements
        \item Palindrome pairs: Store reverse string hashes
    \end{itemize}
    
    \item \textbf{Hybrid Techniques:}
    \begin{itemize}
        \item Hashing + sliding window: 
        \begin{itemize}
            \item Count distinct substrings with fixed length
            \item Maintain window hash while sliding
        \end{itemize}
        \item Hashing + binary search:
        \begin{itemize}
            \item Longest common substring: Binary search length + hash check
        \end{itemize}
        \item Hashing + DFS/BFS:
        \begin{itemize}
            \item Cycle detection in graphs: Store visited states
            \item Game state memoization
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Complexity Analysis:}
    \begin{itemize}
        \item Average case: $O(1)$ insert/lookup/delete
        \item Worst case: $O(n)$ per operation (all collisions)
        \item Rolling hash: $O(n)$ precomputation, $O(1)$ substring hash
    \end{itemize}
    
    \item \textbf{Language-Specific Tips:}
    \begin{itemize}
        \item C++: 
        \begin{itemize}
            \item \texttt{unordered\_map} vs \texttt{map} (hash vs BST)
            \item Custom hash for user-defined types
        \end{itemize}
        \item Java:
        \begin{itemize}
            \item Override \texttt{hashCode()} and \texttt{equals()} together
            \item \texttt{HashMap} load factor and initial capacity tuning
        \end{itemize}
        \item Python:
        \begin{itemize}
            \item Dictionary resizing when $2/3$ full
            \item Keys must be immutable (tuples ok, lists not)
        \end{itemize}
    \end{itemize}
        
    \item \textbf{Testing \& Debugging:}
    \begin{itemize}
        \item Collision testing: Verify distribution with random inputs
        \item Stress testing: Compare against naive implementation
        \item Hash visualization: Check bit distribution patterns
    \end{itemize}
\end{itemize}
\section{Hashing-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Count Distinct Elements in Array & $\mathcal{O}(n)$ & Use unordered set or map to store unique elements. & Use unordered set for $\mathcal{O}(1)$ average ops. & All elements same or all distinct \\
\hline
Frequency of Array Elements & $\mathcal{O}(n)$ & Use hash map to store frequency count. & Use unordered map for fast insert/search. & Large range, negative elements \\
\hline
Intersection and Union of Arrays & $\mathcal{O}(n + m)$ & Use set/map for union and intersection logic. & Store smaller array in hash for space. & One array empty, duplicates \\
\hline
Subarray with Sum = 0 & $\mathcal{O}(n)$ & Use prefix sum and hash set to detect repeats. & Insert prefix sums into hash set as you go. & All zeros, single zero element \\
\hline
Subarray with Xor = k & $\mathcal{O}(n)$ & Use prefix xor and hash set to detect repeats. & Insert prefix xors into hash set as you go. & All zeros, single zero element \\
\hline
Longest Subarray with Given Sum $k$ & $\mathcal{O}(n)$ & Store (prefix sum → index) in hash map. & Keep max length on-the-fly. & Negative numbers, no such subarray \\
\hline
Longest Subarray with Equal 0s and 1s & $\mathcal{O}(n)$ & Replace 0 with -1 and apply prefix sum + hash map. & Transform to subarray with sum = 0. & All 1s or all 0s \\
\hline
Longest Common Binary Subarray with Given Sum & $\mathcal{O}(n)$ & Compute prefix sum diff of both arrays, then find longest span with diff = 0. & Reduce to subarray with 0 difference. & Arrays not same length \\
\hline
Longest Consecutive Subsequence & $\mathcal{O}(n)$ & Insert all in set; for each start of seq, count forward. & Only check seq starting at smallest number. & Unsorted input, repeated numbers \\
\hline
Count Distinct Elements in Every Window & $\mathcal{O}(n)$ & Sliding window with frequency map. & Insert/delete in map while sliding. & Window size $>$ n or = 1 \\
\hline
More than n/k Occurrences in Array & $\mathcal{O}(n)$ & Use hashing to count frequency, then filter $>$ n/k. & Use map of size k to maintain only valid candidate frequencies. & Multiple or no elements qualify \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/hashing}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries STRING}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/string.png}
\end{center}

\chapter{Essential String Techniques }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:string}
\begin{itemize}
    \item \textbf{Character Manipulation Fundamentals:}
    \begin{itemize}
        \item ASCII conversions:
        \begin{itemize}
            \item \texttt{char - '0'} for digit conversion
            \item \texttt{ch \& 31} for case-insensitive bitmask
        \end{itemize}
        \item Character classification:
        \begin{itemize}
            \item \texttt{isdigit(), isalpha(), isalnum()}
            \item Custom bitmask: \texttt{mask |= 1 << (ch - 'a')}
        \end{itemize}
        \item Case conversion:
        \begin{itemize}
            \item \texttt{ch \^{} 32} to toggle case
            \item \texttt{ch | ' '} to lowercase, \texttt{ch \& '\_'} to uppercase
        \end{itemize}
    \end{itemize}
    
    \item \textbf{String Traversal Patterns:}
    \begin{itemize}
        \item Two pointers:
        \begin{itemize}
            \item Opposite-direction: Palindrome checks
            \item Same-direction: Remove duplicates
        \end{itemize}
        \item Sliding window:
        \begin{itemize}
            \item Longest substring without repeating: HashMap + left pointer
            \item Minimum window substring: Frequency map + counter
        \end{itemize}
        \item Reverse traversal:
        \begin{itemize}
            \item Process from end (number addition, path normalization)
            \item Avoid recomputation with suffix arrays
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Substring Search Algorithms:}
    \begin{itemize}
        \item Knuth-Morris-Pratt (KMP):
        \begin{itemize}
            \item Prefix function: \texttt{lps[i] = longest proper prefix/suffix}
            \item Complexity: $O(n + m)$ for text and pattern
        \end{itemize}
        \item Rabin-Karp:
        \begin{itemize}
            \item Rolling hash: $H = (H \cdot \text{base} + \text{ch}) \mod p$
            \item Double hashing for collision safety
        \end{itemize}
        \item Boyer-Moore:
        \begin{itemize}
            \item Bad character rule: Jump tables
            \item Good suffix rule: Complex but efficient in practice
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Palindromic String Techniques:}
    \begin{itemize}
        \item Center expansion:
        \begin{itemize}
            \item Odd/even centers: $O(n^2)$ time, $O(1)$ space
            \item Count palindromic substrings
        \end{itemize}
        \item Manacher's algorithm:
        \begin{itemize}
            \item Linear time: Maintain center and right boundary
            \item Transform: Insert \# between characters
        \end{itemize}
        \item Longest palindromic subsequence:
        \begin{itemize}
            \item Convert to LCS: \texttt{S} vs \texttt{reverse(S)}
            \item Interval DP: \texttt{dp[i][j] = dp[i+1][j-1] + 2} if match
        \end{itemize}
    \end{itemize}
    
    \item \textbf{String Transformation Patterns:}
    \begin{itemize}
        \item Edit distance:
        \begin{itemize}
            \item Wagner-Fischer: \texttt{dp[i][j] = min(insert, delete, replace)}
            \item Space optimization: Two rows
        \end{itemize}
        \item Anagram detection:
        \begin{itemize}
            \item Frequency maps: \texttt{int[26]} for alphabets
            \item Sorting: \texttt{sort(s) == sort(t)}
        \end{itemize}
        \item Group shifted strings:
        \begin{itemize}
            \item Normalize: \texttt{(s[i] - s[0] + 26) \% 26}
            \item Encode as tuple of differences
        \end{itemize}
    \end{itemize}
    
    \item \textbf{String Parsing Techniques:}
    \begin{itemize}
        \item Tokenization:
        \begin{itemize}
            \item State machine: Track in-word/in-space
            \item Library functions: \texttt{split(), strtok()}
        \end{itemize}
        \item Syntax parsing:
        \begin{itemize}
            \item Stack-based: Valid parentheses, tag validation
            \item Recursive descent: Calculator expressions
        \end{itemize}
        \item Path normalization:
        \begin{itemize}
            \item Split by '/', handle '.' and '..' with stack
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Advanced Data Structures:}
    \begin{itemize}
        \item Trie (Prefix tree):
        \begin{itemize}
            \item Structure: \texttt{children[26], isEnd}
            \item Applications: Autocomplete, word search
        \end{itemize}
        \item Suffix array:
        \begin{itemize}
            \item Construct: $O(n \log n)$ with doubling
            \item LCP array: Longest common prefix between suffixes
        \end{itemize}
        \item Suffix automaton:
        \begin{itemize}
            \item Count distinct substrings: $\sum \text{len}(state) - \text{len}(\text{link}(state))$
            \item Find longest repeating substring
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Regular Expression Patterns:}
    \begin{itemize}
        \item Basic matching:
        \begin{itemize}
            \item '.' as wildcard, '*' for repetition
            \item Recursive/DP: Match remaining after '*'
        \end{itemize}
        \item Finite automata:
        \begin{itemize}
            \item NFA: Backtracking implementation
            \item DFA: Table-driven (efficient but large)
        \end{itemize}
    \end{itemize}
    
    \item \textbf{String Compression Techniques:}
    \begin{itemize}
        \item Run-length encoding:
        \begin{itemize}
            \item Encode: \texttt{char + count}
            \item Decode: Expand counts
        \end{itemize}
        \item Huffman coding:
        \begin{itemize}
            \item Min-heap: Merge lowest frequency nodes
            \item Prefix codes: No ambiguity
        \end{itemize}
        \item LZW compression:
        \begin{itemize}
            \item Dictionary-based: Grow codebook
            \item Used in GIF, PDF
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Edge Cases \& Pitfalls:}
    \begin{itemize}
        \item Empty string: Check length before access
        \item Single character strings
        \item Case sensitivity: Often overlooked
        \item Unicode handling: UTF-8 vs ASCII
        \item String immutability: Concatenation $O(n^2)$ time
        \item Null terminators: C-style strings
    \end{itemize}
    
    \item \textbf{Optimization Strategies:}
    \begin{itemize}
        \item Precomputation:
        \begin{itemize}
            \item Prefix sums: For character frequencies
            \item Rolling hash: Precompute powers
        \end{itemize}
        \item Early termination:
        \begin{itemize}
            \item Break when mismatch found
            \item Stop when impossible to improve
        \end{itemize}
        \item Space-time tradeoffs:
        \begin{itemize}
            \item Character maps vs full hash maps
            \item In-place modifications
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Longest substring without repeating: Sliding window + map
        \item String permutations: Frequency map + two pointers
        \item Minimum window substring: Expand right, contract left
        \item Word break: DP with substring lookup
        \item Encode/decode strings: Delimiters or length prefix
    \end{itemize}
    
    \item \textbf{Hybrid Techniques:}
    \begin{itemize}
        \item KMP + DP: Pattern matching with wildcards
        \item Trie + DFS: Word search in grid
        \item Suffix array + binary search: Longest common substring
        \item Rolling hash + sliding window: Rabin-Karp for multiple patterns
    \end{itemize}
    
    \item \textbf{Language-Specific Nuances:}
    \begin{itemize}
        \item Python:
        \begin{itemize}
            \item Strings immutable: Use list for mutation, \texttt{''.join()}
            \item Slicing: $O(k)$ for slice of length $k$
        \end{itemize}
        \item Java:
        \begin{itemize}
            \item \texttt{StringBuilder} for mutable operations
            \item \texttt{intern()} for constant pool
        \end{itemize}
        \item C++:
        \begin{itemize}
            \item \texttt{std::string::npos} for not found
            \item \texttt{substr(start, length)} $O(n)$ operation
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Testing \& Debugging:}
    \begin{itemize}
        \item Unicode tests: Emojis, multi-byte characters
        \item Empty and single-character inputs
        \item Repeated character strings
        \item Case-sensitive vs insensitive checks
        \item Off-by-one in loops: Use \texttt{<= length} vs \texttt{< length}
    \end{itemize}
    
    \item \textbf{Advanced Applications:}
    \begin{itemize}
        \item Z-algorithm: Linear time pattern search
    \end{itemize}
\end{itemize}
\section{String-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Reverse Words in a Given String & $\mathcal{O}(n)$ & Reverse whole string, then reverse each word. & Trim extra spaces and handle in-place if needed. & Multiple spaces, trailing spaces \\
\hline
Is Subsequence of Other & $\mathcal{O}(n)$ & Two pointer approach to match characters. & Return early when end is reached. & Empty subsequence, longer target \\
\hline
Sort Anagrams Together & $O(n \cdot k \log k)$ & Use hashmap of sorted string → list of anagrams & Use tuple(sorted(word)) as key & Empty strings \\
\hline
Naive Pattern Searching & $\mathcal{O}((n - m + 1) \cdot m)$ & Slide pattern over text and check match at each index. & Stop inner loop early on mismatch. & Pattern at end, repeated chars \\
\hline
Rabin-Karp Algorithm & Avg: $\mathcal{O}(n + m)$, Worst: $\mathcal{O}(nm)$ & Use rolling hash to compare hash values of pattern and text. & Use large prime modulus to avoid collisions. & Hash collision, overlapping matches \\
\hline
KMP Algorithm & $\mathcal{O}(n + m)$ & Preprocess LPS array to skip redundant checks. & Use LPS array for efficient jump in pattern. & Pattern equals text, repeated patterns \\
\hline
Check if Strings are Rotations & $\mathcal{O}(n)$ & Concatenate original string with itself and search other. & Use KMP or inbuilt substring search. & Same strings, empty strings \\
\hline
Longest Substring with Distinct Characters & $\mathcal{O}(n)$ & Use sliding window with hash set to track seen characters. & Use two pointers to maintain window. & All characters same, all distinct \\
\hline
Lexicographical Rank of a String & $\mathcal{O}(n^2)$ or $\mathcal{O}(n)$ with precomputation & Count smaller chars on right and use factorial logic. & Precompute factorials and use freq count. & Duplicate characters, repeated pattern \\
\hline
Anagram Search & $\mathcal{O}(n)$ & Sliding window + freq count comparison. (Note: Basic anagram search can't done using xor). & Use count arrays or hash map with difference counter. & Overlapping anagrams, repeated chars \\
\hline
Longest Palindromic Substring & $O(n^2)$ & Expand around center for even and odd palindrome & Expand preferred: less space & Multiple longest substrings \\
\hline

Count of Distinct Substrings 
  & \(O(n^2\log n)\) 
  & Build a suffix array in \(O(n\log n)\), compute the LCP array in \(O(n)\), then use  
    \(\frac{n(n+1)}2 - \sum\mathrm{LCP}\) to count distinct substrings. 
  & \(O(n)\) via suffix‐automaton  
    (or \(O(n\log n)\) with suffix‐array + LCP) 
  & \(n=0\) (empty string),  
    all characters identical 
\\\hline

Longest Repeating Substring 
  & \(O(n^2)\) brute‐force or DP 
  & Construct suffix‐array + LCP; optionally binary‐search on substring length and
    check via LCP (or rolling‐hash) 
  & \(O(n\log n)\) using suffix‐array + binary‐search 
    (or \(O(n)\) with SA + direct LCP scan) 
  & All characters distinct (no repeat),  
    \(n<2\) 
\\\hline
Z-function String Matching & $O(n)$ & $Z[i]$ = length of prefix starting at $i$ matching $s[0..]$ & Useful for pattern matching: use "$P\$T$" trick & Pattern at end or not found \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/strings}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries LINKED-LIST}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/linkedlist.png}
\end{center}

\chapter{Essential Linked List Techniques }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:linked}
\begin{itemize}
    \item \textbf{Pointer Manipulation Fundamentals:}
    \begin{itemize}
        \item Iterative traversal: 
        \begin{itemize}
            \item \texttt{while (current != null) \{ ... current = current.next; \}}
            \item Always check \texttt{current.next} before accessing
        \end{itemize}
        \item Node deletion: 
        \begin{itemize}
            \item Standard: \texttt{prev.next = current.next}
            \item Without prev pointer: Copy \texttt{next} node data and skip
        \end{itemize}
        \item Pointer assignment order: Critical for reversal and insertion
    \end{itemize}
    
    \item \textbf{Two Pointers Technique:}
    \begin{itemize}
        \item Fast-slow pointers:
        \begin{itemize}
            \item Cycle detection: Fast (2x) catches slow if cycle exists
            \item Middle node: Slow at middle when fast reaches end
            \item Cycle length: Freeze slow, move fast until meet again
        \end{itemize}
        \item Distance-based pointers:
        \begin{itemize}
            \item Nth from end: Advance first pointer N steps, then move both
            \item Intersection: Traverse both lists, reset pointers at end
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Recursion Patterns:}
    \begin{itemize}
        \item Reverse linked list:
        \begin{itemize}
            \item Base case: \texttt{if (head == null || head.next == null) return head}
            \item Recurse: \texttt{newHead = reverse(head.next)}
            \item Adjust: \texttt{head.next.next = head; head.next = null}
        \end{itemize}
        \item Tree-like operations:
        \begin{itemize}
            \item Merge two sorted lists: Compare heads and recurse
            \item Validate palindrome: Recurse to middle and compare while backtracking
        \end{itemize}
        \item Stack-based processing:
        \begin{itemize}
            \item Process nodes backwards (reverse order)
            \item Add numbers from least significant digit
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Dummy Node Technique:}
    \begin{itemize}
        \item Usage scenarios:
        \begin{itemize}
            \item Head might change (reversal, partition)
            \item Avoiding null pointer checks
            \item Merging multiple lists
        \end{itemize}
        \item Implementation:
        \begin{itemize}
            \item \texttt{ListNode dummy = new ListNode(0)}
            \item \texttt{dummy.next = head}
            \item Return \texttt{dummy.next}
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Cycle Detection \& Handling:}
    \begin{itemize}
        \item Floyd's algorithm:
        \begin{itemize}
            \item Phase 1: Detect cycle (fast meets slow)
            \item Phase 2: Find start - reset slow to head, advance both 1x speed
        \end{itemize}
        \item Cycle removal: Break link at start node
        \item Cycle length: Measure distance between meeting points
    \end{itemize}
    
    \item \textbf{Advanced Reversal Patterns:}
    \begin{itemize}
        \item Reverse in groups:
        \begin{itemize}
            \item Iterative: Reverse K nodes, connect to next group
            \item Recursive: Reverse first K, recurse for rest
        \end{itemize}
        \item Reverse between indices:
        \begin{itemize}
            \item Mark node before start, reverse segment, reconnect
        \end{itemize}
        \item Reverse alternately: Skip nodes between reversed groups
    \end{itemize}
    
    \item \textbf{Merge Patterns:}
    \begin{itemize}
        \item Merge two sorted lists:
        \begin{itemize}
            \item Iterative: Compare and build new list
            \item Recursive: Smaller node.next = merge(remaining)
        \end{itemize}
        \item Merge K sorted lists:
        \begin{itemize}
            \item Priority queue: O(N log K) time
            \item Divide and conquer: Pairwise merging
        \end{itemize}
        \item Merge sort on linked lists:
        \begin{itemize}
            \item Find middle (fast-slow), recurse halves, merge
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Deep Copy Techniques:}
    \begin{itemize}
        \item Copy with random pointers:
        \begin{itemize}
            \item Two-pass: Create node map, then connect pointers
            \item Weaving: $A->A'->B->B'$, then separate
        \end{itemize}
        \item Clone complex structures: Use hashmap for O(1) node access
    \end{itemize}
    
    \item \textbf{Edge Cases:}
    \begin{itemize}
        \item Empty list (head = null)
        \item Single node list
        \item Two-node list (tests pointer swaps)
        \item Head/tail modification cases
        \item Cyclic lists
        \item Large lists (recursion stack overflow)
    \end{itemize}
    
    \item \textbf{Optimization Strategies:}
    \begin{itemize}
        \item Space-time tradeoffs:
        \begin{itemize}
            \item Hashmap for O(1) node access (extra O(n) space)
            \item In-place reversal (O(1) space)
        \end{itemize}
        \item Early termination:
        \begin{itemize}
            \item Stop when cycle detected
            \item Break when sorted order violated
        \end{itemize}
        \item Parallel processing:
        \begin{itemize}
            \item Multiple pointers for complex traversals
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Hybrid Techniques:}
    \begin{itemize}
        \item Two pointers + recursion:
        \begin{itemize}
            \item Find middle, recurse left and right (palindrome)
            \item Reorder list: Reverse second half and weave
        \end{itemize}
        \item Dummy node + two pointers:
        \begin{itemize}
            \item Partition list: Build left and right lists, then combine
        \end{itemize}
        \item Cycle detection + reversal:
        \begin{itemize}
            \item Problems requiring cycle removal then reordering
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Add two numbers: Digit-by-digit sum with carry
        \item LRU cache: DLL + hashmap
        \item Rotate list: Connect tail to head, break at (len - k)
        \item Remove duplicates: Sorted - skip duplicates; Unsorted - use hashset
        \item Flatten multilevel DLL: DFS of child pointers
    \end{itemize}
    
    \item \textbf{Debugging Tips:}
    \begin{itemize}
        \item Visualize small lists (3-5 nodes)
        \item Draw pointer changes before coding
        \item Check null pointers after every .next access
        \item Use circular list detection in debugger
        \item Test with even/odd length lists
    \end{itemize}
    
    \item \textbf{Complexity Analysis:}
    \begin{itemize}
        \item Reversal: O(n) time, O(1) space (iterative)
        \item Cycle detection: O(n) time, O(1) space
        \item Recursion: O(n) time, O(n) stack space
        \item Merge K lists: O(N log K) time, O(K) space
    \end{itemize}
\end{itemize}
\section{Linked List-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Insert at Given Position in Singly Linked List & $\mathcal{O}(n)$ & Traverse to (pos-1), update links for insertion. & Handle position 1 separately (head insert). & Invalid position, empty list \\
\hline
Reverse a Doubly Linked List & $\mathcal{O}(n)$ & Swap prev and next of all nodes and update head. & In-place with no extra space. & Empty list, one node \\
\hline
Detect Loop in a Linked List & $\mathcal{O}(n)$ & Use Floyd’s Cycle Detection (slow/fast pointer). & Avoid extra space using two pointers. & Self-loop, no loop \\
\hline
Detect and Remove Loop in Linked List & $\mathcal{O}(n)$ & Use Floyd’s algo to detect, then find loop start and remove. & Modify next of loop node to NULL. & Loop starts at head \\
\hline
Find Intersection Point of Two Linked Lists & $\mathcal{O}(m + n)$ & Use length diff or hash set to identify merge point. & Align both lists by skipping diff nodes. & No intersection, intersect at head \\
\hline
Middle of Linked List & $\mathcal{O}(n)$ & Use slow and fast pointers. & Return slow when fast hits end. & Even number of nodes \\
\hline
Nth Node from End of Linked List & $\mathcal{O}(n)$ & Use two pointers: move first $n$ ahead, then move both. & Single pass approach. & n $>$ length, n = length \\
\hline
Reverse Linked List in Groups of k & $\mathcal{O}(n)$ & Recursively reverse every k nodes. & Track next group head before reversal. & k = 1, not multiple of k \\
\hline
Delete Node with Only Pointer to It & $\mathcal{O}(1)$ & Copy data from next node and delete next. & Works only if node is not last. & Node is last node (invalid) \\
\hline
Segregate Even and Odd Nodes & $\mathcal{O}(n)$ & Create two lists (even, odd), then join them. & Maintain original order in each part. & All even or all odd \\
\hline
Pairwise Swap Nodes of Linked List & $\mathcal{O}(n)$ & Swap data or pointers in pairs recursively or iteratively. & Use pointer manipulation for clean swap. & Odd number of nodes \\
\hline
Clone a Linked List with Random Pointer & $\mathcal{O}(n)$ & Create clone nodes, interleave them, set randoms, then separate. & O(1) space if done in-place. & Randoms form cycles or NULLs \\
\hline
LRU Cache Design & $\mathcal{O}(1)$ per op & Use hash map + doubly linked list to store and order keys. & Use custom DLL for O(1) insert/delete. & Full cache, repeated accesses \\
\hline
Merge Two Sorted Linked Lists & $\mathcal{O}(n + m)$ & Use dummy node and merge by comparing values. & Can be done iteratively or recursively. & One list empty, all nodes equal \\
\hline
Palindrome Linked List & $\mathcal{O}(n)$ & Find middle, reverse second half, compare halves. & Restore list if needed after check. & Odd length, all same elements \\
\hline
Add One to Linked List (Add two Numbers forward) & $O(n)$ & Reverse → Add → Carry → Reverse back & Use dummy node if carry at head & All 9s (carry propagation) \\
\hline

Rotate Linked List by K & $O(n)$ & Find length, make list circular, break at $n-k$ & Use modulo $k = k \% n$ & $k > n$, $k = 0$ \\
\hline
Flatten a Linked List & $O(n \log n)$ & Merge K sorted linked lists via heap or recursion & Use divide-and-conquer for optimal merge & All next = NULL \\
\hline
LFU Cache Design & $O(1)$ avg & Use hashmap + frequency list (doubly linked) & Combine LFU with LRU by frequency bucket & Capacity = 0 \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/linked_lists}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries STACK}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/stack.png}
\end{center}

\chapter{Essential Stack Techniques }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:stack}
\begin{itemize}
    \item \textbf{Stack Fundamentals:}
    \begin{itemize}
        \item LIFO principle: Last-In-First-Out behavior
        \item Core operations:
        \begin{itemize}
            \item \texttt{push(item)}: Add to top ($O(1)$)
            \item \texttt{pop()}: Remove from top ($O(1)$)
            \item \texttt{top()/peek()}: Access top element ($O(1)$)
        \end{itemize}
        \item Implementation: 
        \begin{itemize}
            \item Arrays (fixed size)
            \item Dynamic arrays (vectors)
            \item Linked lists (rarely needed)
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Parentheses Validation Patterns:}
    \begin{itemize}
        \item Basic validation:
        \begin{itemize}
            \item Push opening brackets, pop on closing brackets
            \item Check stack empty at end
        \end{itemize}
        \item Complex variants:
        \begin{itemize}
            \item Multiple bracket types (\{\}, [], ())
            \item Minimum add to make valid: Track imbalance count
            \item Score of parentheses: Recursive stack evaluation
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Monotonic Stack Patterns:}
    \begin{itemize}
        \item Next Greater Element (NGE):
        \begin{itemize}
            \item Decreasing stack: Pop while current $>$ stack top
            \item Left NGE: Traverse right-to-left
            \item Circular arrays: Double array length or modulo index
        \end{itemize}
        \item Stock span problem:
        \begin{itemize}
            \item Decreasing stack: Pop while price $>=$ stack top
            \item Span = current index - stack top index
        \end{itemize}
        \item Largest rectangle in histogram:
        \begin{itemize}
            \item Increasing stack: Pop while current $<$ stack top
            \item Area = height[pop] $\times$ (i - stack top - 1)
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Expression Evaluation:}
    \begin{itemize}
        \item Infix to postfix:
        \begin{itemize}
            \item Operator stack + precedence rules
            \item Shunting-yard algorithm
        \end{itemize}
        \item Postfix evaluation:
        \begin{itemize}
            \item Operand stack: Push numbers, pop on operators
            \item Handle unary operators (-, !)
        \end{itemize}
        \item Basic calculator:
        \begin{itemize}
            \item Two stacks: Operands and operators
            \item Handle precedence and parentheses
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Recursion Simulation:}
    \begin{itemize}
        \item DFS traversal:
        \begin{itemize}
            \item Explicit stack replaces recursion
            \item Push (node, state) for complex traversals
        \end{itemize}
        \item Tree traversals:
        \begin{itemize}
            \item Inorder: Push left until null, pop, go right
            \item Preorder: Process node, push right then left
        \end{itemize}
        \item Tower of Hanoi: Track source, destination, auxiliary
    \end{itemize}
    
    \item \textbf{Undo/Redo Operations:}
    \begin{itemize}
        \item Dual stack approach:
        \begin{itemize}
            \item Main stack + undo stack
            \item Redo: Pop from undo, push to main
        \end{itemize}
        \item Text editor operations:
        \begin{itemize}
            \item Store (operation, state) pairs
            \item Support nested undos
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Advanced Stack Techniques:}
    \begin{itemize}
        \item Min/Max stack:
        \begin{itemize}
            \item Dual stack: Main stack + min/max stack
            \item Single stack: Store tuple (value, current-min)
        \end{itemize}
        \item Rainwater trapping:
        \begin{itemize}
            \item Decreasing stack: Compute water between bounds
            \item Alternative: Two-pointer approach
        \end{itemize}
        \item Asteroid collision:
        \begin{itemize}
            \item Push positives, handle negatives by destruction logic
            \item Direction-based collisions
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Hybrid Techniques:}
    \begin{itemize}
        \item Stack + DFS:
        \begin{itemize}
            \item Iterative DFS for trees/graphs
            \item Flood fill with stack
        \end{itemize}
        \item Stack + Math:
        \begin{itemize}
            \item Evaluate RPN with operator functions
            \item Compute nested expressions recursively
        \end{itemize}
        \item Stack + Hashmap:
        \begin{itemize}
            \item Next greater element with value mapping
            \item Valid parentheses with bracket mapping
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Edge Cases \& Pitfalls:}
    \begin{itemize}
        \item Empty stack: Check before pop/peek
        \item Single element stacks
        \item Negative numbers in expression evaluation
        \item Equal elements in monotonic stacks
        \item Circular array boundary conditions
        \item Large input stack overflow (recursive DFS)
    \end{itemize}
    
    \item \textbf{Optimization Strategies:}
    \begin{itemize}
        \item Precomputation:
        \begin{itemize}
            \item Pre-calculate next greater elements
            \item Store prefix max/min arrays
        \end{itemize}
        \item Space optimization:
        \begin{itemize}
            \item Single-stack min/max tracking
            \item Reuse input array as stack
        \end{itemize}
        \item Early termination:
        \begin{itemize}
            \item Invalid parentheses detection
            \item Collision completion detection
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Daily temperatures: NGE variant
        \item Remove k digits: Monotonic increasing stack
        \item Validate stack sequences: Simulate push/pop
        \item Exclusive time of functions: Stack with timestamps
        \item Decode string: Stack for nested expansions
    \end{itemize}
    
    \item \textbf{Language-Specific Nuances:}
    \begin{itemize}
        \item C++: \texttt{stack} container (no iteration)
        \item Java: \texttt{Stack} class (thread-safe) or \texttt{ArrayDeque}
        \item Python: List as stack (\texttt{append()}, \texttt{pop()})
        \item JavaScript: Array with \texttt{push()}, \texttt{pop()}
    \end{itemize}
    
    \item \textbf{Testing \& Debugging:}
    \begin{itemize}
        \item Small test cases: 0-3 elements
        \item Verify stack state after each operation
        \item Print stack contents in complex algorithms
        \item Boundary tests: Empty input, max size
        \item Monotonic property verification
    \end{itemize}
    
    \item \textbf{When to Use Stack:}
    \begin{itemize}
        \item Nested structures (parentheses, tags)
        \item Nearest greater/smaller element problems
        \item DFS traversal without recursion
        \item Undo/redo functionality
        \item History tracking (browser back button)
        \item Problems requiring LIFO processing
    \end{itemize}
\end{itemize}
\section{Stack-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
\hline
Balanced Parentheses & $\mathcal{O}(n)$ & Use stack to match opening and closing brackets. & Use map for matching pairs. & Unmatched opening/closing, nested brackets \\
\hline
Sort a Stack & $O(n^2)$ & Use recursion: pop element, sort rest, insert in correct pos recursively. & Simulate with another stack if iterative version needed. & Stack with equal elements or single element \\
\hline
Implement K Stacks in an Array & $\mathcal{O}(1)$ per operation & Use one array + 2 extra arrays (top, next) with free list. & Use space efficiently with linked list logic. & Stack overflow, empty pop \\
\hline
Stock Span Problem & $\mathcal{O}(n)$ & Use stack to track indexes of previous higher values. & Store indices, not values. & All elements increasing/decreasing \\
\hline
Previous Greater Element & $\mathcal{O}(n)$ & Traverse from left, use stack to store elements. & Pop smaller elements for current. & No greater element exists \\
\hline
Next Greater Element & $\mathcal{O}(n)$ & Traverse from right, use stack for next greater. & Reverse loop and build result. & Last element, decreasing order \\
\hline
Largest Rectangular Area in Histogram & $\mathcal{O}(n)$ & Use stack to store indices, calculate area with every pop. & Append 0 at end for flush. & All bars same height, decreasing order \\
\hline
Stack with getMin() in $\mathcal{O}(1)$ & $\mathcal{O}(1)$ & Use auxiliary stack or encode min in main stack. & Push modified value to track min. & All elements same, large range \\
\hline
Sum of Subarray Minimums & $O(n)$ & Use Monotonic Stack to find PLE/NLE and apply contribution: \newline $\text{ans} += arr[i] \cdot (i - prev) \cdot (next - i)$ & Use modulo if result large & Duplicates, strictly decreasing \\
\hline
Remove K Digits to Make Minimum & $O(n)$ & Greedy using Monotonic Stack: remove previous digit if it's greater & Remove from end if needed after stack pass & Leading zeros \\
\hline
Infix to Postfix Conversion & $\mathcal{O}(n)$ & Use stack for operators, precedence and associativity. & Use function for priority comparison. & Parentheses, unary operators \\
\hline
Evaluation of Postfix Expression & $\mathcal{O}(n)$ & Use stack, push operand, evaluate on operator. & Ensure operator has required operands. & Division by zero, invalid postfix \\
\hline
Infix to Prefix Conversion & $\mathcal{O}(n)$ & Reverse infix, convert to postfix, then reverse result. & Use same logic as infix-postfix with reversed precedence. & Nested brackets, invalid format \\
\hline
Evaluation of Prefix Expression & $\mathcal{O}(n)$ & Traverse right to left, use stack for operands. & Evaluate when operator is found. & Invalid expressions \\
\hline
Largest Rectangle with All 1's (Binary Matrix) & $\mathcal{O}(n \cdot m)$ & Convert rows into histogram, use histogram method row-wise. & Reuse logic from histogram problem. & Single row/column, all 0's or all 1's \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/stack}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries QUEUE DEQUE}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/queue.png}
\end{center}

\chapter{Essential Queue \& Deque Techniques }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:queue}
\begin{itemize}
    \item \textbf{Core Concepts:}
    \begin{itemize}
        \item FIFO principle: First-In-First-Out (Queue)
        \item Double-ended operations: Insert/remove at both ends (Deque)
        \item Complexity:
        \begin{itemize}
            \item Enqueue/dequeue: $O(1)$
            \item Access front/rear: $O(1)$
            \item Search: $O(n)$
        \end{itemize}
        \item Implementations:
        \begin{itemize}
            \item Circular arrays (fixed size)
            \item Linked lists (dynamic size)
            \item Language support: \texttt{Queue}, \texttt{Deque} (Python), \texttt{ArrayDeque} (Java), \texttt{deque} (C++)
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Breadth-First Search (BFS):}
    \begin{itemize}
        \item Level-order traversal:
        \begin{itemize}
            \item Process nodes level by level
            \item Queue size = current level nodes
        \end{itemize}
        \item Shortest path in unweighted graphs:
        \begin{itemize}
            \item Maintain distance array
            \item Queue neighbors of current node
        \end{itemize}
        \item Multi-source BFS:
        \begin{itemize}
            \item Initialize queue with multiple sources
            \item Applications: Rotting oranges, nearest gate
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Sliding Window Patterns:}
    \begin{itemize}
        \item Maximum in sliding window:
        \begin{itemize}
            \item Monotonic decreasing deque
            \item Maintain indices: Front always max, remove smaller elements from rear
        \end{itemize}
        \item Minimum in sliding window:
        \begin{itemize}
            \item Monotonic increasing deque
            \item Remove larger elements from rear
        \end{itemize}
        \item First negative in window:
        \begin{itemize}
            \item Deque storing negative indices
            \item Remove indices outside current window
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Deque-Specific Patterns:}
    \begin{itemize}
        \item Palindrome checker:
        \begin{itemize}
            \item Compare front and rear while deque size > 1
        \end{itemize}
        \item Steque (stack + queue):
        \begin{itemize}
            \item Push front (stack), push back (queue)
            \item Implement with single deque
        \end{itemize}
        \item Deque rotation:
        \begin{itemize}
            \item Rotate elements: \texttt{deque.rotate(n)} (Python)
            \item Manual rotation with push/pop
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Scheduling \& Buffering:}
    \begin{itemize}
        \item Task scheduling:
        \begin{itemize}
            \item Round-robin scheduling with queue
            \item Priority queues for weighted scheduling
        \end{itemize}
        \item Producer-consumer pattern:
        \begin{itemize}
            \item Queue as buffer between producers/consumers
            \item Synchronization required in concurrency
        \end{itemize}
        \item Recent counter:
        \begin{itemize}
            \item Maintain queue of timestamps
            \item Evict expired requests from front
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Advanced Algorithms:}
    \begin{itemize}
        \item Binary tree serialization:
        \begin{itemize}
            \item Level-order using queue (BFS)
            \item Handle null nodes explicitly
        \end{itemize}
        \item Snake game:
        \begin{itemize}
            \item Deque representing snake body
            \item Move: Push new head, pop tail (unless growing)
        \end{itemize}
        \item Cache implementations:
        \begin{itemize}
            \item FIFO cache: Queue for eviction order
            \item LRU cache: Deque + hashmap (or doubly linked list)
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Monotonic Queue Techniques:}
    \begin{itemize}
        \item Next greater element (variation):
        \begin{itemize}
            \item Use deque instead of stack
            \item Process elements in sequence
        \end{itemize}
        \item Constrained subsequence sum:
        \begin{itemize}
            \item Deque storing indices of useful values
            \item Maintain decreasing order (max at front)
        \end{itemize}
        \item Shortest subarray with sum at least K:
        \begin{itemize}
            \item Monotonic increasing deque for prefix sums
            \item Remove larger prefix sums from rear
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Hybrid Techniques:}
    \begin{itemize}
        \item Queue + Hashmap:
        \begin{itemize}
            \item First unique character: Store counts + queue
            \item Evict non-unique characters from front
        \end{itemize}
        \item Deque + Stack:
        \begin{itemize}
            \item Implement stack using deque
            \item Implement deque using stacks
        \end{itemize}
        \item Queue + Priority Queue:
        \begin{itemize}
            \item Sliding window median: Two heaps + delayed removal
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Edge Cases \& Pitfalls:}
    \begin{itemize}
        \item Empty queue/deque: Check before pop
        \item Single element operations
        \item Fixed size queues: Overflow handling
        \item Circular queue: Full/empty state detection
        \item Negative numbers in sliding window
        \item Large K in sliding window (K > array size)
        \item Concurrency issues in producer-consumer
    \end{itemize}
    
    \item \textbf{Optimization Strategies:}
    \begin{itemize}
        \item Precomputation:
        \begin{itemize}
            \item Prefix sums for subarray problems
            \item Frequency counts for unique elements
        \end{itemize}
        \item Lazy removal:
        \begin{itemize}
            \item Mark elements as invalid instead of immediate removal
            \item Clean during peek operations
        \end{itemize}
        \item Space efficiency:
        \begin{itemize}
            \item Store indices instead of values
            \item Reuse input array as queue buffer
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Sliding window maximum: Monotonic deque
        \item Rotting oranges: Multi-source BFS
        \item Design circular queue: Fixed-size implementation
        \item Open the lock: BFS with state transitions
        \item Reveal cards in increasing order: Deque simulation
        \item Gas station circuit: Queue for circular tour
    \end{itemize}
    
    \item \textbf{Language-Specific Nuances:}
    \begin{itemize}
        \item Python:
        \begin{itemize}
            \item \texttt{collections.deque}: Thread-safe, O(1) operations
            \item \texttt{queue.Queue}: Synchronized for threads
        \end{itemize}
        \item Java:
        \begin{itemize}
            \item \texttt{ArrayDeque}: Resizable array, not thread-safe
            \item \texttt{LinkedList}: Implements Deque interface
        \end{itemize}
        \item C++:
        \begin{itemize}
            \item \texttt{std::queue}: Container adapter
            \item \texttt{std::deque}: Random access, efficient push/pop both ends
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Testing \& Debugging:}
    \begin{itemize}
        \item Verify FIFO property with sequential inputs
        \item Check deque operations at both ends
        \item Test empty, single-element, full-capacity states
        \item Validate BFS level tracking
        \item Visualize monotonic deque state during sliding window
    \end{itemize}
    
    \item \textbf{When to Use Queue vs Deque:}
    \begin{itemize}
        \item Queue: Pure FIFO processing (BFS, buffering)
        \item Deque:
        \begin{itemize}
            \item Sliding window min/max
            \item Palindrome processing
            \item Steque (stack + queue) requirements
            \item Efficient front removal in certain algorithms
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Advanced Applications:}
    \begin{itemize}
        \item Work stealing algorithms: Deque per processor
        \item Undo history: Deque for limited history
        \item Graph edge rotation: Deque for efficient edge swapping
    \end{itemize}
\end{itemize}
\section{Queue \& Deque-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
\hline
Circular Implementation of Queue & $\mathcal{O}(1)$ & Use array with front and rear pointers modulo array size. & Handle full/empty with count or extra space. & Queue full vs empty detection \\
\hline
Implementing Stack using Queue & Push: $\mathcal{O}(n)$, Pop: $\mathcal{O}(1)$ & Use 2 queues or rotate in single queue during push. & Push elements to maintain LIFO order. & Popping from empty stack \\
\hline
Implementing Queue using Single Stack & $\mathcal{O}(n)$ amortized & Use recursion to simulate queue behavior. & Use function call stack as helper. & Stack overflow, empty queue \\
\hline
Reversing First K Elements of a Queue & $\mathcal{O}(n)$ & Use stack to reverse first k, then enqueue back. & Use queue rotation for remaining elements. & k $>$ size, k = 0 or size \\
\hline
Sliding Window Maximum & $\mathcal{O}(n)$ & Use deque to maintain decreasing order of indices. & Remove out-of-window and smaller elements. & All elements equal or decreasing \\
\hline
Generate Numbers with Given Digits Only & $\mathcal{O}(n)$ & Use queue to generate using BFS (e.g., only {5,6}). & Enqueue number + each digit. & Handle leading zeros \\
\hline
Circular Implementation of Deque & $\mathcal{O}(1)$ & Use circular array with front and rear pointers. & Wrap around using modulo. & Full/empty condition handling \\
\hline
First Circular Tour (Gas Station Problem) & $\mathcal{O}(n)$ & Use two pointers or one-pass tracking surplus. & Start from station with net positive gas. & No solution exists \\
\hline
Design a Data Structure with Min and Max & $\mathcal{O}(1)$ per op & Use deque for max and min separately. & Sync with actual queue insertions/deletions. & Same elements, all increasing/decreasing \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/queues}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries TREE \& BST}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/tree.png}
\end{center}

\chapter{Essential Tree \& BST Techniques }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:tree}
\begin{itemize}
    \item \textbf{Core Concepts:}
    \begin{itemize}
        \item Tree properties:
        \begin{itemize}
            \item $n$ nodes $\Rightarrow$ $n-1$ edges
            \item Height: $h = O(\log n)$ (balanced), $O(n)$ (unbalanced)
            \item BST invariant: $\text{left} < \text{root} < \text{right}$
        \end{itemize}
        \item Representations:
        \begin{itemize}
            \item Node-based: \texttt{TreeNode(val, left, right)}
            \item Array-based: Index $i \rightarrow$ children at $2i+1, 2i+2$
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Traversal Techniques:}
    \begin{itemize}
        \item Depth-First Search (DFS):
        \begin{itemize}
            \item Preorder: Root $\rightarrow$ Left $\rightarrow$ Right
            \item Inorder: Left $\rightarrow$ Root $\rightarrow$ Right (BST $\rightarrow$ sorted)
            \item Postorder: Left $\rightarrow$ Right $\rightarrow$ Root
        \end{itemize}
        \item Breadth-First Search (BFS):
        \begin{itemize}
            \item Level-order: Queue-based, $O(n)$
            \item Reverse level-order: Process from bottom
        \end{itemize}
        \item Morris traversal: $O(1)$ space (threaded trees)
    \end{itemize}
    
    \item \textbf{Binary Tree Patterns:}
    \begin{itemize}
        \item Path problems:
        \begin{itemize}
            \item Root-to-leaf paths: DFS with backtracking
            \item Path sum: Target sum checks
            \item Maximum path sum: Postorder with max gain
        \end{itemize}
        \item View problems:
        \begin{itemize}
            \item Left/right view: BFS tracking first/last node
            \item Top/bottom view: Vertical order + offset tracking
        \end{itemize}
        \item Ancestor problems:
        \begin{itemize}
            \item LCA: Recursive search for both nodes
            \item BST LCA: Use BST property to prune
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Binary Search Tree Patterns:}
    \begin{itemize}
        \item Validation:
        \begin{itemize}
            \item Inorder traversal $\rightarrow$ sorted check
            \item Range propagation: $(\min, \max)$ per node
        \end{itemize}
        \item Modification:
        \begin{itemize}
            \item Insert: Find appropriate leaf position
            \item Delete: Handle 0, 1, and 2 children cases
            \item BST to balanced BST: Inorder $\rightarrow$ rebuild
        \end{itemize}
        \item Order statistics:
        \begin{itemize}
            \item Kth smallest: Inorder with counter
            \item Size tracking: Augment node with subtree size
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Advanced Tree Algorithms:}
    \begin{itemize}
        \item Tree building:
        \begin{itemize}
            \item Preorder+Inorder $\rightarrow$ Binary tree
            \item Sorted array $\rightarrow$ Balanced BST
        \end{itemize}
        \item Serialization/Deserialization:
        \begin{itemize}
            \item BFS with null markers
            \item Preorder with special characters
        \end{itemize}
        \item Subtree problems:
        \begin{itemize}
            \item Subtree of Another Tree: Compare all nodes
            \item Merkle hashing: $O(n+m)$ subtree comparison
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Tree Augmentation:}
    \begin{itemize}
        \item Subtree sum: Update on insert/delete
        \item Lazy propagation: Batch updates for range queries
        \item AVL/RB trees: Height balancing rotations
    \end{itemize}
    
    \item \textbf{Special Tree Types:}
    \begin{itemize}
        \item Trie (Prefix tree):
        \begin{itemize}
            \item Word search: Store characters on edges
            \item Applications: Autocomplete, IP routing
        \end{itemize}
        \item Fenwick Tree (Binary Indexed Tree):
        \begin{itemize}
            \item Point updates, prefix sums in $O(\log n)$
            \item Convert array to frequency tree
        \end{itemize}
        \item Segment Tree:
        \begin{itemize}
            \item Range queries: Sum/min/max in $O(\log n)$
            \item Lazy propagation for range updates
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Optimization Strategies:}
    \begin{itemize}
        \item Memoization: Cache subtree results
        \item Pruning: Early termination in DFS
        \item Iterative DFS: Avoid recursion overhead
        \item Path compression: In union-find trees
    \end{itemize}
    
    \item \textbf{Edge Cases \& Pitfalls:}
    \begin{itemize}
        \item Empty tree (null root)
        \item Single node tree
        \item Skewed trees (performance degradation)
        \item Duplicate values in BST (define policy)
        \item Integer overflow in large trees
        \item Cyclic graphs (non-tree inputs)
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Validate BST: Range propagation
        \item BST iterator: Stack-based DFS
        \item Inorder successor: BST property navigation
        \item House robber III: Tree DP (take/skip)
        \item Symmetric tree: Mirror comparison
    \end{itemize}
    
    \item \textbf{Tree DP Patterns:}
    \begin{itemize}
        \item Diameter of tree: $\max(\text{left}+\text{right})$
        \item Maximum path sum: Postorder with max gain
        \item Tree coloring: Min cameras/guards
        \item Isomorphism: Compare structures recursively
    \end{itemize}
    
    \item \textbf{Hybrid Techniques:}
    \begin{itemize}
        \item BFS + HashMap: Vertical order traversal
        \item DFS + Stack: Iterative traversals
        \item Tree + Two pointers: BST two-sum
        \item BST + Binary search: Kth smallest
    \end{itemize}
    
    \item \textbf{Testing \& Debugging:}
    \begin{itemize}
        \item Small trees: 0-3 nodes
        \item Skewed trees: Left/right chains
        \item Complete trees: All levels filled
        \item Duplicate value handling
        \item Visualization tools: Graphviz output
    \end{itemize}
\end{itemize}
\section{Tree-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Iterative Inorder Traversal & $\mathcal{O}(n)$ & Use stack to simulate recursion. Push left nodes, then visit right. & Use controlled while loop with current node and stack. & Empty tree, single node \\
\hline
Iterative Preorder Traversal & $\mathcal{O}(h)$ & Use stack, push right first, then left. & Avoid putting left on stack just put right after processing left. & Left-skewed or right-skewed tree \\
\hline
Iterative Postorder Traversal & $\mathcal{O}(n)$ & Use two stacks or one stack with visited flag. & Reverse modified preorder (root-right-left). & Single node, skewed tree \\
\hline
Threaded Binary Tree Inorder Traversal & $\mathcal{O}(n)$ & Use right threads for successors, avoid recursion/stack. & Morris traversal modifies tree temporarily. & No left/right child, restore tree \\
\hline
Pre, In, Post Order in Single DFS & $O(n)$ & Use stack and state tracking (1: pre, 2: in, 3: post) per node & Push state-tuple to stack instead of recursion & Empty tree \\
\hline
Pre, In, Post Order via BFS & $O(n)$ & Not standard — simulate by storing BFS with level and direction info & Mainly used for printing levels differently & Level-wise variant only \\
\hline
Morris Inorder Traversal & $O(n)$ & Use threaded tree (predecessor’s right = current), no stack/recursion & Restore tree links after traversal & Tree with only right nodes \\
\hline
Morris Preorder Traversal & $O(n)$ & Same as inorder but print before going to left subtree & Restore links carefully & Skewed trees \\
\hline
Level Order Traversal & $\mathcal{O}(n)$ & Use queue for BFS traversal by levels. & Track level ends with size or marker. & Empty tree \\
\hline
Left, Right, Top, Bottom View of Tree & $\mathcal{O}(n)$ & Use queue + map for horizontal distance or level. & Track first/last node at each level or HD. & Nodes at same level or HD \\
\hline
Check for Balanced Binary Tree & $\mathcal{O}(n)$ & Recursively get height and check balance. & Return -1 early if unbalanced. & Perfectly skewed tree \\
\hline
Maximum Width of Binary Tree & $\mathcal{O}(n)$ & Level order with index tracking for each node. & Normalize indices per level to avoid overflow. & Tree with missing internal nodes \\
\hline
Construct Tree from Inorder and Preorder & $\mathcal{O}(n)$ & Use preorder index and map for inorder positions. & Use hashmap to speed up root index lookup. & Invalid or repeated values \\
\hline
Tree Traversal in Spiral Form & $\mathcal{O}(n)$ & Use two stacks or deque to alternate direction. & Use direction flag to control insertion. & Skewed trees \\
\hline
Child Sum Property in Tree & $\mathcal{O}(n)$ & Check if node value = sum of children recursively. & Leaf node automatically satisfies. & Null children, 0 values \\
\hline
Convert Binary Tree to Doubly Linked List & $\mathcal{O}(n)$ & Inorder traversal with prev pointer to link nodes. & Use static/global prev pointer. & Single node, skewed trees \\
\hline
Convert Binary Tree to Singly Linked List & $\mathcal{O}(n)$ & Preorder traversal and right-only links. & Recursively attach left-subtree to right. & All left children \\
\hline
Finding LCA in Binary Tree & $\mathcal{O}(n)$ & Recursively return current node if matches either, else combine. & Return ancestor if both sides return non-null. & LCA is one of the nodes \\
\hline
Burn a Binary Tree From a Leaf & $\mathcal{O}(n)$ & Use BFS and parent map, simulate fire spreading level-wise. & Build parent links first, then run BFS. & Leaf is root, isolated nodes \\
\hline
Serialize and Deserialize Binary Tree & $\mathcal{O}(n)$ & Use preorder with NULL markers or level order. & Use delimiter or marker for NULLs. & NULL-heavy or skewed tree \\
\hline
Insertion in Binary Tree & $\mathcal{O}(n)$ & Level order traversal, insert at first empty left/right. & Use queue to find first incomplete node. & Tree is full, insertion at root \\
\hline
Deletion in Binary Tree & $\mathcal{O}(n)$ & Replace target with deepest node, then delete deepest. & Track parent of deepest separately. & Node not found, deleting root \\
\hline
Convert Binary Tree into Mirror Tree & $\mathcal{O}(n)$ & Recursively swap left and right subtrees. & Post-order traversal ensures bottom-up swap. & Symmetric trees \\
\hline
Count Nodes in Complete Binary Tree & $\mathcal{O}(\log^2 n)$ & Use height comparison of left and right subtrees. & Apply binary search if needed. & Perfect or skewed tree \\
\hline
Diameter of a Binary Tree & $\mathcal{O}(n)$ & Recursively compute height + update diameter at each node. & Store height in return to avoid recomputation. & Tree with only left/right nodes \\
\hline
Max Path Sum (Any Node to Any Node) & $O(n)$ & At each node: return max(root, root + L, root + R), update global max as $\max(global, root + L + R)$ & Use postorder and maintain global max & All negative nodes (return max node) \\
\hline
Max Path Sum Leaf to Leaf & $O(n)$ & If both children exist: update global as $L + R + root$, return max(L, R) + root & Handle leaf-only subtree separately & Single child nodes, leaf = root \\
\hline
Count All Paths with Given Sum in Binary Tree & $O(n)$ & Prefix sum + hashmap: count paths where sum(curr) - target exists in map. & Backtrack prefix sum count while unwinding recursion. & Negative values, path not from root \\
\hline
Diameter of N-ary Tree & $O(n)$ & At each node, store 2 largest child heights, update diameter as $h1 + h2 + 1$ & Maintain global diameter in postorder traversal & Single node or single branch \\
\hline
Boundary Traversal of Binary Tree & $O(n)$ & Print root → left boundary (non-leaf) → leaves → right boundary (reverse) & Handle duplicates of leaf nodes properly & Single node / skewed tree \\
\hline
Child Sum Property & $O(n)$ & Modify tree: for each node, make child sum = node value recursively & Update child or node as needed to preserve invariant & Leaf node base case \\
\hline
Burning Tree from a Leaf & $O(n)$ & Use parent map + BFS from the leaf node to simulate burn time level-wise & Track visited to avoid reprocessing & Leaf not existing or multiple leaves \\
\hline
Binary Tree to Linked List (Morris-based) & $O(n)$ & Morris + rearrange right pointers during preorder visit & Use a dummy node or prev tracker & Single node or all left nodes \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/trees}
\newgeometry{margin=0.2in}
\clearpage
\section{Binary Search Tree-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Deletion in BST & $\mathcal{O}(h)$ & Use recursive approach for 0,1,2 children; replace with inorder successor/predecessor. & Use minimum from right subtree for replacement. & Leaf node, root node, only one child \\
\hline
Floor/Ceil in BST & $\mathcal{O}(h)$ & Traverse and update closest lesser/greater values. & BST property helps skip subtrees. & No floor/ceil exists \\
\hline
Inorder Successor / Predecessor in BST & $O(h)$ & For successor: go right once, then extreme left; else track last ancestor where node came from left. & Use BST property for early pruning. & Node is largest/smallest \\
\hline
BST Sequences (All Arrays that Make Same BST) & $O(C_n)$ (Exponential) & Recursively combine left and right BST sequences using **weaving** of lists preserving order. & Use backtracking with prefix + interleaving. & Skewed trees or duplicates \\
\hline
Random Node in BST with Equal Probability & $O(\log n)$ avg & Maintain subtree sizes at each node, use random index to pick. & Augment BST with size field and use random index traversal. & Skewed trees, duplicates \\
\hline
AVL Tree Rotations & $\mathcal{O}(\log n)$ & Perform LL, RR, LR, RL rotation based on balance factor. & Update heights after rotation. & Rotations on root, duplicate keys \\
\hline
Find Kth Smallest in BST & $\mathcal{O}(h + k)$ & Inorder traversal and count nodes until k. & Augment with subtree sizes for $\mathcal{O}(\log n)$ time. & k $>$ n, empty BST \\
\hline
Check for BST & $\mathcal{O}(n)$ & Use min/max bounds or inorder traversal (increasing order). & Avoid invalid assumption on child value only. & Duplicate values, skewed tree \\
\hline
Fix BST with Two Nodes Swapped & $\mathcal{O}(n)$ & Inorder traversal, detect violated pairs and swap back. & Use one pass with prev node pointer. & Swapped nodes are non-adjacent or adjacent \\
\hline
Pair Sum with Given BST $\mathcal{O}(\log n)$ space & $\mathcal{O}(n)$ & Use two stack-based iterators (inorder \& reverse inorder). & Avoid full inorder array to save space. & No pair exists, same node not allowed \\
\hline
Finding LCA in BST & $\mathcal{O}(h)$ & Traverse down: if both $< or >$ , move accordingly other wise return that root. & BST property gives O(h) approach. & One node is ancestor of other \\
\hline
Largest BST in Binary Tree & $O(n)$ & Postorder: return isBST, min, max, size from children & Maintain global max size & All nodes invalid BST (return 0) \\
\hline
2 Sum in BST using Iterator & $O(n)$ & Inorder \& reverse-inorder iterators, check sum via two-pointer logic & BSTIterator with stack, no full traversal & Sum not present or duplicates \\
\hline
Rank from Stream & $O(\log n)$ & BST with left subtree size tracking; insert and rank queries supported & Augment BST with count & Duplicate numbers \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/bst}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries HEAP}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/heap.png}
\end{center}

\chapter{Essential Heap Techniques }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:heap}
\begin{itemize}
    \item \textbf{Heap Fundamentals:}
    \begin{itemize}
        \item Min-heap vs Max-heap:
        \begin{itemize}
            \item Min-heap: Root is smallest element (default in Python, Java)
            \item Max-heap: Root is largest element (implement with negative values)
        \end{itemize}
        \item Complexity:
        \begin{itemize}
            \item Insertion: $O(\log n)$
            \item Extraction: $O(\log n)$
            \item Peek: $O(1)$
            \item Heapify: $O(n)$
        \end{itemize}
        \item Implementation:
        \begin{itemize}
            \item Binary heap: Array representation with $i \rightarrow 2i+1, 2i+2$
            \item Language support: \texttt{heapq} (Python), \texttt{PriorityQueue} (Java), \texttt{priority\_queue} (C++)
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Top-K Patterns:}
    \begin{itemize}
        \item Kth largest/smallest:
        \begin{itemize}
            \item Min-heap for Kth largest (keep heap size = k)
            \item Max-heap for Kth smallest
            \item Complexity: $O(n \log k)$ vs $O(n \log n)$ sorting
        \end{itemize}
        \item Top K frequent elements:
        \begin{itemize}
            \item Count frequencies + min-heap of size k
            \item Alternative: Bucket sort for $O(n)$ when frequencies bounded
        \end{itemize}
        \item K closest points:
        \begin{itemize}
            \item Max-heap based on distance (evict largest when size > k)
            \item Compare using squared distance to avoid sqrt
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Stream Processing:}
    \begin{itemize}
        \item Median finder:
        \begin{itemize}
            \item Two heaps: Max-heap (left half), min-heap (right half)
            \item Balance: $|left| \leq |right| \leq |left| + 1$
            \item Median: Root of larger heap or average of roots
        \end{itemize}
        \item Sliding window median:
        \begin{itemize}
            \item Two heaps + lazy deletion hashmap
            \item Rebalance when heap tops are outside window
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Scheduling \& Greedy:}
    \begin{itemize}
        \item Meeting rooms II:
        \begin{itemize}
            \item Min-heap of end times (track active meetings)
            \item Extract when $start \geq min(end)$
        \end{itemize}
        \item Task scheduler:
        \begin{itemize}
            \item Max-heap of frequencies + queue for cooldown
            \item Pattern: Execute highest frequency task, push to cooldown
        \end{itemize}
        \item Course schedule III:
        \begin{itemize}
            \item Max-heap of durations + greedy deadline management
            \item Replace longest task when new task can't fit
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Pathfinding \& Graph Algorithms:}
    \begin{itemize}
        \item Dijkstra's algorithm:
        \begin{itemize}
            \item Min-heap of (distance, node)
            \item Decrease-key alternative: Multiple entries + visited set
        \end{itemize}
        \item Prim's MST:
        \begin{itemize}
            \item Min-heap of (edge-weight, node)
            \item Grow tree with cheapest edge
        \end{itemize}
        \item A* search:
        \begin{itemize}
            \item Min-heap of $f(n) = g(n) + h(n)$
            \item Heuristic must be admissible ($h(n) \leq$ actual cost)
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Multiple Heap Techniques:}
    \begin{itemize}
        \item Min-max heap:
        \begin{itemize}
            \item Single DS supporting min and max in $O(1)$
            \item Alternative: Store two heaps with value mapping
        \end{itemize}
        \item K-way merge:
        \begin{itemize}
            \item Min-heap of (val, list-id, index)
            \item Extract min, push next from same list
        \end{itemize}
        \item Heap of heaps:
        \begin{itemize}
            \item Problems requiring partitioned heaps (e.g., multi-dimensional data)
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Custom Heap Operations:}
    \begin{itemize}
        \item Heapify with custom comparator:
        \begin{itemize}
            \item Python: \texttt{heapq} with tuples \texttt{(priority, value)}
            \item C++: \texttt{priority\_queue<T, vector<T>, Compare>}
        \end{itemize}
        \item Decrease-key optimization:
        \begin{itemize}
            \item Without native support: Push duplicate entries + lazy deletion
            \item Track entry version for invalidation
        \end{itemize}
        \item Remove arbitrary element:
        \begin{itemize}
            \item Maintain auxiliary heap for deleted items
            \item Lazy cleanup when tops match
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Edge Cases \& Pitfalls:}
    \begin{itemize}
        \item Empty heap: Check size before pop/top
        \item Duplicate values: Secondary comparator for stability
        \item Large heaps: Memory constraints with $O(n)$ space
        \item Floating points: Precision issues in distance calculations
        \item Stale entries: In lazy deletion schemes
        \item Concurrent access: Not thread-safe in most implementations
    \end{itemize}
    
    \item \textbf{Optimization Strategies:}
    \begin{itemize}
        \item Batch processing:
        \begin{itemize}
            \item Heapify entire collection instead of sequential inserts
            \item Reduces $O(n \log n)$ to $O(n)$
        \end{itemize}
        \item Size limitation:
        \begin{itemize}
            \item For top-k: Maintain heap size = k (save memory and time)
        \end{itemize}
        \item Precomputation:
        \begin{itemize}
            \item Compute distances/frequencies before heap operations
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Hybrid Techniques:}
    \begin{itemize}
        \item Heap + Hashmap:
        \begin{itemize}
            \item LFU cache: Heap of (frequency, time, key) + key-value map
            \item Efficient updates with lazy deletion
        \end{itemize}
        \item Heap + Stack:
        \begin{itemize}
            \item Monotonic stack + heap for problems like largest rectangle
        \end{itemize}
        \item Heap + Union-Find:
        \begin{itemize}
            \item Kruskal's MST with heap for edges + UF for connectivity
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Advanced Applications:}
    \begin{itemize}
        \item Huffman coding:
        \begin{itemize}
            \item Min-heap of frequencies, merge smallest two
        \end{itemize}
        \item External sorting:
        \begin{itemize}
            \item K-way merge of sorted chunks using heap
        \end{itemize}
        \item Skyline problem:
        \begin{itemize}
            \item Max-heap of heights with sweep line
            \item Remove heights when building exits view
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Problem-Specific Patterns:}
    \begin{itemize}
        \item Kth largest in stream: Min-heap of size k
        \item Maximum performance team: Sort efficiency + min-heap for speed
        \item Reorganize string: Max-heap by frequency with cooldown
        \item Find median from data stream: Two-heap technique
        \label{itm:median}
        \item Minimum cost to connect sticks: Always merge smallest two
    \end{itemize}
    
    \item \textbf{Testing \& Debugging:}
    \begin{itemize}
        \item Validate heap properties: Parent $<$ children (min-heap)
        \item Check balance in two-heap structures
        \item Test with duplicate values
        \item Verify lazy deletion cleanup
        \item Small case verification: 0,1,2,3 elements
    \end{itemize}
    
    \item \textbf{Language-Specific Nuances:}
    \begin{itemize}
        \item Python:
        \begin{itemize}
            \item \texttt{heapq} is min-heap only
            \item Use \texttt{heapq.\_heapify\_max} for max-heap (limited operations)
        \end{itemize}
        \item Java:
        \begin{itemize}
            \item \texttt{PriorityQueue} min-heap default
            \item Max-heap: \texttt{new PriorityQueue<>(Collections.reverseOrder())}
        \end{itemize}
        \item C++:
        \begin{itemize}
            \item \texttt{priority\_queue<T>} is max-heap
            \item Min-heap: \texttt{priority\_queue<T, vector<T>, greater<T>>}
        \end{itemize}
    \end{itemize}
\end{itemize}
\section{Heap-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Heapify (min/max) & $\mathcal{O}(\log n)$ & Percolate down from given node to maintain heap property. & Start from last non-leaf node during build. & Node already satisfies heap \\
\hline
Build Heap & $\mathcal{O}(n)$ & Call heapify from last internal node to root. & Better than inserting one-by-one ($\mathcal{O}(n \log n)$). & Array already a heap \\
\hline
Insertion in Heap & $\mathcal{O}(\log n)$ & Insert at end, percolate up to fix violation. & Maintain array representation. & Duplicate or largest element \\
\hline
Decrease Key in Min Heap & $\mathcal{O}(\log n)$ & Update value and percolate up to restore heap. & Only decrease allowed in min-heap. & Key already smallest \\
\hline
Extract Min from Min Heap & $\mathcal{O}(\log n)$ & Replace root with last node, heapify down. & Efficient removal from top. & Heap has only one element \\
\hline
Heap Sort & $\mathcal{O}(n \log n)$ & Build max-heap, repeatedly extract max to end of array. & In-place, not stable. & Already sorted input \\
\hline
Sort K-Sorted Array & $\mathcal{O}(n \log k)$ & Use min-heap of size $k+1$ to get smallest available. & Maintain heap of current $k$ range. & k = 0 or very large \\
\hline
Buy Maximum Items with Given Sum & $\mathcal{O}(n + k \log n)$ & Sort or use min-heap, pick smallest until sum exhausted. & Use heap for faster access to smallest. & All items more than budget \\
\hline
K Largest Elements & $\mathcal{O}(n \log k)$ & Use min-heap of size k, keep top k largest. & Maintain heap of k elements. & k $>$ n \\
\hline
K Closest Elements & $\mathcal{O}(n \log k)$ & Use max-heap by distance from target. & Store elements as (diff, value). & Multiple same distance \\
\hline
Merge K Sorted Arrays (Similiar for K LL also) & $\mathcal{O}(n \log k)$ & Use min-heap to push smallest elements from each array. & Heap stores (value, array index, element index). & Varying lengths \\
\hline
Median of a Stream & $\mathcal{O}(\log n)$ & Use max-heap for left half and min-heap for right half. & Keep size difference $\leq 1$. & All elements same or increasing \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/heap}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries GREEDY ALGO}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/greedy.png}
\end{center}

\chapter{Essential Greedy Algorithm Techniques }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:greedy}
\begin{itemize}
    \item \textbf{Core Greedy Principles:}
    \begin{itemize}
        \item Greedy choice property: Locally optimal choice leads to global optimum
        \item Optimal substructure: Solution to subproblems contributes to main solution
        \item Prove correctness: Use exchange argument or mathematical induction
    \end{itemize}
    
    \item \textbf{Interval Scheduling Patterns:}
    \begin{itemize}
        \item Activity selection:
        \begin{itemize}
            \item Sort by finish time, select earliest finishing
            \item Proof: Maximizes remaining time for more activities
        \end{itemize}
        \item Meeting rooms II:
        \begin{itemize}
            \item Track active meetings with min-heap (earliest end time)
            \item Complexity: $O(n \log n)$
        \end{itemize}
        \item Merge intervals:
        \begin{itemize}
            \item Sort by start time, merge overlapping intervals
            \item Edge: Adjacent intervals [1,3] and [3,5] → merge to [1,5]
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Coin Change Variants:}
    \begin{itemize}
        \item Canonical systems: Greedy works (e.g., US coins: 1,5,10,25)
        \item Non-canonical systems: Requires DP (e.g., [1,3,4] for sum 6)
        \item Proof requirement: Must verify system is canonical
    \end{itemize}
    
    \item \textbf{Optimization Problems:}
    \begin{itemize}
        \item Fractional knapsack:
        \begin{itemize}
            \item Sort by value/weight ratio, take highest first
            \item Contrast: 0/1 knapsack requires DP
        \end{itemize}
        \item Job sequencing:
        \begin{itemize}
            \item Sort by profit, assign to latest possible slot
            \item Use disjoint-set for efficient slot finding
        \end{itemize}
        \item Huffman coding:
        \begin{itemize}
            \item Merge lowest frequency nodes with min-heap
            \item Complexity: $O(n \log n)$
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Array Transformation Patterns:}
    \begin{itemize}
        \item Minimum increments:
        \begin{itemize}
            \item Make array strictly increasing: $arr[i] = \max(arr[i], arr[i-1]+1)$
            \item Total operations: $\sum \max(0, arr[i-1]+1 - arr[i])$
        \end{itemize}
        \item Gas station problems:
        \begin{itemize}
            \item Circular tour: Track deficit, reset when gas < 0
            \item Proof: If total gas $\geq$ total cost, solution exists
        \end{itemize}
    \end{itemize}
    
    \item \textbf{String Manipulation:}
    \begin{itemize}
        \item Lexicographical ordering:
        \begin{itemize}
            \item Remove k digits for smallest number: Use monotonic stack
            \item Edge: Leading zeros removal
        \end{itemize}
        \item Valid parentheses:
        \begin{itemize}
            \item Balance count: Increment for '(', decrement for ')'
            \item Greedy: Track current balance, fail if negative
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Advanced Greedy Patterns:}
    \begin{itemize}
        \item K-way merging:
        \begin{itemize}
            \item Merge k sorted lists: Always pick smallest head using min-heap
            \item Extendible to external sorting
        \end{itemize}
        \item Egyptian fractions:
        \begin{itemize}
            \item Represent fraction as sum of unit fractions: $\frac{a}{b} = \frac{1}{\lceil b/a \rceil} + \cdots$
            \item Terminate when numerator becomes 1
        \end{itemize}
        \item Minimum spanning tree:
        \begin{itemize}
            \item Prim: Grow tree from vertex with min-heap
            \item Kruskal: Sort edges, add smallest that doesn't form cycle
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Proof Techniques:}
    \begin{itemize}
        \item Greedy stays ahead: Show greedy is never worse than optimal
        \item Exchange argument: Transform optimal solution to greedy solution
        \item Mathematical induction: Base case and inductive step
        \item Counterexample search: Verify for small cases
    \end{itemize}
    
    \item \textbf{Edge Cases \& Pitfalls:}
    \begin{itemize}
        \item Empty input: Zero activities, empty array
        \item Single element: Trivial solutions
        \item Duplicate values: Stable sort to preserve order
        \item Negative values: Gas can be negative, values in knapsack
        \item Integer overflow: Large sums in operations count
        \item Ties in sorting: Secondary sort criteria matters
    \end{itemize}
    
    \item \textbf{Hybrid Approaches:}
    \begin{itemize}
        \item Greedy + Two pointers:
        \begin{itemize}
            \item Container with most water: Shorter line moves inward
        \end{itemize}
        \item Greedy + Binary search:
        \begin{itemize}
            \item Split array largest sum: Binary search on possible maximums
        \end{itemize}
        \item Greedy + DFS/BFS:
        \begin{itemize}
            \item Dijkstra: Greedy choice in priority queue
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Common Problem Patterns:}
    \begin{itemize}
        \item Jump game I/II: Track maximum reachable index
        \item Candy distribution: Two-pass left-right then right-left
        \item Task scheduler: Schedule most frequent first with cooling
        \item Reorganize string: Place most frequent char first with heap
        \item Boats to save people: Sort and two pointers from ends
    \end{itemize}
    
    \item \textbf{Optimization Strategies:}
    \begin{itemize}
        \item Sorting optimization:
        \begin{itemize}
            \item Only sort necessary elements
            \item Use counting sort when possible
        \end{itemize}
        \item Early termination:
        \begin{itemize}
            \item Stop when solution becomes invalid
            \item Break when optimal solution found early
        \end{itemize}
        \item Space-time tradeoffs:
        \begin{itemize}
            \item Store additional state for O(1) decisions
            \item Precompute prefix/suffix arrays
        \end{itemize}
    \end{itemize}
    
    \item \textbf{When to Avoid Greedy:}
    \begin{itemize}
        \item When local optimum doesn't lead to global optimum
        \item When problem requires reconsidering earlier choices
        \item When constraints suggest DP $(n \leq 1000 \quad \text{vs} \quad n \leq 10^6)$

        \item When greedy choice isn't obvious or provable
    \end{itemize}
    
    \item \textbf{Testing \& Debugging:}
    \begin{itemize}
        \item Small test cases: Verify with hand-calculated results
        \item Property testing: Check invariants during execution
        \item Compare with brute force: For small n
        \item Corner cases: Max/min values, empty sets, duplicates
    \end{itemize}
\end{itemize}
\section{Greedy Algorithm-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead

\hline
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Activity Selection Problem & $\mathcal{O}(n \log n)$ & Sort by finish time, select next non-overlapping activity. & Always pick earliest finishing activity. & All activities overlap or same finish time \\
\hline
Fractional Knapsack Problem & $\mathcal{O}(n \log n)$ & Sort items by value/weight ratio, take fraction if needed. & Use greedy for max value/unit weight. & All items too heavy or too light \\
\hline
Job Sequencing Problem & $\mathcal{O}(n \log n + n d)$ & Sort jobs by profit, assign to latest free slot before deadline. & Use disjoint set/array for free slot finding. & Jobs with same deadlines or 0 deadline \\
\hline
Huffman Coding & $\mathcal{O}(n \log n)$ & Build min-heap of frequencies, combine lowest two recursively. & Use priority queue for optimal code tree. & All frequencies same or 1 symbol only \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/greedy}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries RECURSION}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/recursion.png}
\end{center}

\chapter{Essential Techniques for Recursion }
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:recursion}
\begin{itemize}[leftmargin=*]
    \item \textbf{Core Concepts:}
    \begin{itemize}
        \item Base Case: The stopping condition that prevents infinite recursion
        \item Recursive Case: The part where function calls itself with modified parameters
        \item State Reduction: Each recursive call should move closer to base case
        \item Trust the Process: Assume recursive calls work correctly for smaller inputs
        \item Call Stack: Understanding how function calls are stored and managed
    \end{itemize}

    \item \textbf{Recursion Design Process:}
    \begin{itemize}
        \item Step 1: Identify the smallest possible input (base case)
        \item Step 2: Define what the function should return for base case
        \item Step 3: Assume function works for smaller inputs
        \item Step 4: Use smaller solutions to build current solution
        \item Step 5: Ensure each call moves toward base case
        \item Step 6: Verify termination condition is always reachable
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Linear Recursion:}
    \begin{itemize}
        \item Factorial Pattern: $f(n) = n \times f(n-1)$ with $f(0)=1$
        \item Fibonacci Pattern: $f(n)=f(n-1)+f(n-2)$ with base cases
        \item Sum Pattern: $sum(n)=n + sum(n-1)$ for arithmetic operations
        \item Countdown Pattern: Process element, recurse on remaining elements
        \item Build-up Pattern: Recurse first, then process current element
    \end{itemize}

    \item \textbf{Tree Recursion:}
    \begin{itemize}
        \item Binary Tree Traversal: Process root, recurse on left and right subtrees
        \item Path Sum Problems: Check if path exists with given sum
        \item Tree Height/Depth: $height=1+\max(leftHeight,\,rightHeight)$
        \item Diameter Problems: Maximum path length through any node
        \item Symmetric Tree: Check if tree is mirror of itself
    \end{itemize}

    \item \textbf{Divide and Conquer:}
    \begin{itemize}
        \item Merge Sort Pattern: Divide array, sort halves, merge results
        \item Quick Sort Pattern: Choose pivot, partition, recurse on subarrays
        \item Binary Search Pattern: Compare with middle, recurse on appropriate half
        \item Maximum Subarray: Divide array, find max in left, right, and crossing
        \item Closest Pair: Divide points, find closest in each half and across
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Backtracking:}
    \begin{itemize}
        \item Template Pattern: Choose → Explore → Unchoose (backtrack)
        \item Permutation Generation: Generate all arrangements of elements
        \item Combination Generation: Generate all subsets of given size
        \item N-Queens Problem: Place queens without attacking each other
        \item Sudoku Solver: Fill grid following Sudoku rules
        \item Maze Solving: Find path through maze using backtracking
        \item Graph Coloring: Assign colors to vertices without conflicts
    \end{itemize}

    \item \textbf{Memoization (Top-Down DP):}
    \begin{itemize}
        \item Overlapping Subproblems: Same inputs computed multiple times
        \item Cache Results: Store computed results to avoid recomputation
        \item Hash Map Cache: Use map/dictionary for flexible parameter caching
        \item Array Cache: Use arrays when parameters have fixed bounds
        \item Multi-dimensional Cache: For functions with multiple parameters
        \item Cache Key Design: How to map function parameters to cache keys
    \end{itemize}

    \item \textbf{Tail Recursion:}
    \begin{itemize}
        \item Tail Call Optimization: When recursive call is the last operation
        \item Accumulator Pattern: Pass accumulated result as parameter
        \item Iterative Conversion: Convert tail recursion to iteration
        \item Stack Space Optimization: Reduce stack usage through tail calls
        \item Continuation Passing: Alternative approach to tail recursion
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Array/List Recursion:}
    \begin{itemize}
        \item Head-Tail Pattern: Process first element, recurse on rest
        \item Two-Pointer Recursion: Recursively process from both ends
        \item Subarray Problems: Recurse on different subarrays
        \item Reverse Array: Swap elements recursively from ends
        \item Array Search: Binary search and linear search variations
        \item Merge Operations: Combine sorted arrays recursively
    \end{itemize}

    \item \textbf{String Recursion:}
    \begin{itemize}
        \item Palindrome Check: Compare first and last characters recursively
        \item String Reversal: Build reversed string character by character
        \item Substring Generation: Generate all possible substrings
        \item Pattern Matching: Recursive string matching algorithms
        \item Edit Distance: Minimum operations to transform strings
        \item Longest Common Subsequence: Find common subsequence recursively
    \end{itemize}

    \item \textbf{Tree and Graph Recursion:}
    \begin{itemize}
        \item DFS Implementation: Recursive depth-first search
        \item Path Finding: Find paths between nodes recursively
        \item Tree Construction: Build trees from traversal sequences
        \item Subtree Problems: Solve problems within subtrees
        \item Graph Cycle Detection: Detect cycles using recursive DFS
        \item Topological Sort: Recursive implementation using DFS
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Number Theory:}
    \begin{itemize}
        \item GCD/LCM: Euclidean algorithm using recursion
        \item Modular Exponentiation: $a^b \bmod m$ using fast exponentiation
        \item Prime Factorization: Recursive factorization algorithms
        \item Catalan Numbers: Recursive computation with applications
        \item Pascal's Triangle: Binomial coefficients using recursion
    \end{itemize}

    \item \textbf{Combinatorics:}
    \begin{itemize}
        \item Permutation Count: $P(n,r)=n\times P(n-1,r-1)$
        \item Combination Count: $C(n,r)=C(n-1,r-1)+C(n-1,r)$
        \item Subset Generation: Generate all $2^n$ subsets
        \item Partition Problems: Ways to partition numbers or sets
        \item Stirling Numbers: Recursive computation for set partitions
    \end{itemize}

    \item \textbf{Geometry:}
    \begin{itemize}
        \item Fractal Generation: Recursive geometric patterns
        \item Convex Hull: Divide and conquer approach
        \item Closest Pair: Recursive solution for closest point pair
        \item Area Calculation: Recursive polygon area computation
        \item Tree Structures: Recursive geometric tree problems
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Avoiding Stack Overflow:}
    \begin{itemize}
        \item Iterative Conversion: Convert recursion to iteration when possible
        \item Tail Recursion: Use tail calls to reduce stack usage
        \item Explicit Stack: Simulate recursion using explicit stack
        \item Increase Stack Limit: Platform-specific stack size increases
        \item Divide Problem Size: Reduce recursion depth by different partitioning
    \end{itemize}

    \item \textbf{Performance Optimization:}
    \begin{itemize}
        \item Memoization: Cache results to avoid redundant calculations
        \item Early Termination: Return immediately when answer is found
        \item Pruning: Skip branches that can't lead to optimal solution
        \item Parameter Optimization: Minimize number of parameters passed
        \item Reference Passing: Avoid copying large data structures
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{When to Use Recursion:}
    \begin{itemize}
        \item Self-Similar Structure: Problem has similar subproblems
        \item Tree/Graph Problems: Natural recursive structure
        \item Divide and Conquer: Problem can be divided into similar subproblems
        \item Backtracking Needed: Need to explore all possibilities
        \item Mathematical Induction: Problem follows inductive structure
        \item Nested Structures: Data has recursive nesting
    \end{itemize}

    \item \textbf{When NOT to Use Recursion:}
    \begin{itemize}
        \item Simple Iteration: Linear problems better solved iteratively
        \item Stack Overflow Risk: Very deep recursion with large inputs
        \item No Overlapping Subproblems: Pure recursion without memoization inefficient
        \item Tail Recursion: Often better converted to iteration
        \item Memory Constraints: Limited stack space available
    \end{itemize}
\end{itemize}
\begin{itemize}[leftmargin=*]
    \item \textbf{Search Problems:}
    \begin{itemize}
        \item Binary Search: Recursive elimination of half search space
        \item Depth-First Search: Recursive graph/tree exploration
        \item Backtracking Search: Explore all paths with backtracking
        \item Branch and Bound: Recursive optimization with pruning
        \item Game Trees: Minimax algorithm for two-player games
    \end{itemize}

    \item \textbf{Generation Problems:}
    \begin{itemize}
        \item Permutation Generation: All arrangements of elements
        \item Combination Generation: All selections of elements
        \item Subset Generation: All possible subsets
        \item Parentheses Generation: All valid parentheses combinations
        \item Path Generation: All paths between points
    \end{itemize}

    \item \textbf{Optimization Problems:}
    \begin{itemize}
        \item Knapsack Problem: Recursive choice—include or exclude item
        \item Coin Change: Minimum coins for amount using recursion
        \item Edit Distance: Minimum operations to transform strings
        \item Longest Increasing Subsequence: Recursive DP approach
        \item Matrix Chain Multiplication: Optimal parenthesization
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Parameter Design:}
    \begin{itemize}
        \item Minimal Parameters: Pass only necessary information
        \item Index Parameters: Use indices instead of creating subarrays
        \item Accumulator Parameters: Build result as parameter
        \item State Parameters: Track current state of computation
        \item Boundary Parameters: Pass start/end indices for ranges
    \end{itemize}

    \item \textbf{Return Value Strategies:}
    \begin{itemize}
        \item Direct Return: Return computed value directly
        \item Boolean Return: Return success/failure status
        \item Multiple Returns: Return multiple values using pairs/tuples
        \item Reference Parameters: Modify parameters instead of returning
        \item Global Variables: Use global state for complex returns
    \end{itemize}

    \item \textbf{Base Case Design:}
    \begin{itemize}
        \item Empty Input: Handle empty arrays, strings, trees
        \item Single Element: Handle single element cases
        \item Boundary Values: Handle minimum/maximum input values
        \item Invalid Input: Handle invalid or edge case inputs
        \item Multiple Base Cases: Some problems need several base cases
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Common Mistakes:}
    \begin{itemize}
        \item Missing Base Case: Recursion never terminates
        \item Wrong Base Case: Incorrect return value for base case
        \item Infinite Recursion: Parameters don't move toward base case
        \item Stack Overflow: Recursion too deep for available stack
        \item Parameter Errors: Incorrect parameter passing in recursive calls
    \end{itemize}

    \item \textbf{Debugging Techniques:}
    \begin{itemize}
        \item Trace Execution: Manually trace through small examples
        \item Print Statements: Add debug prints to track recursive calls
        \item Call Stack Visualization: Draw call stack for understanding
        \item Base Case Testing: Test base cases independently
        \item Parameter Validation: Verify parameters are changing correctly
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Quick Implementation:}
    \begin{itemize}
        \item Template Patterns: Memorize common recursive templates
        \item Standard Algorithms: Know recursive implementations of standard algorithms
        \item Memoization Template: Have ready template for memoized recursion
        \item Backtracking Template: Standard backtracking structure
        \item Tree Traversal: Quick implementations of tree algorithms
    \end{itemize}

    \item \textbf{Problem Analysis:}
    \begin{itemize}
        \item Constraint Analysis: Check if recursion depth will be manageable
        \item Time Complexity: Analyze recursive time complexity using recurrence relations
        \item Space Complexity: Consider call stack space in addition to explicit space
        \item Subproblem Identification: Look for overlapping subproblems
        \item Pattern Matching: Recognize which recursive pattern applies
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Mutual Recursion:}
    \begin{itemize}
        \item Even-Odd Functions: Functions that call each other alternately
        \item State Machine: Recursive implementation of state machines
        \item Grammar Parsing: Recursive descent parsers
        \item Game Theory: Player alternation in game tree search
        \item Protocol Implementation: Network protocol state handling
    \end{itemize}

    \item \textbf{Higher-Order Recursion:}
    \begin{itemize}
        \item Functions as Parameters: Pass functions to recursive functions
        \item Currying: Transform multi-parameter recursion
        \item Continuation Passing: Advanced control flow techniques
        \item Lazy Evaluation: Delay computation in recursive structures
        \item Functional Programming: Pure functional recursive approaches
    \end{itemize}

    \item \textbf{Mathematical Analysis:}
    \begin{itemize}
        \item Recurrence Relations: $T(n)=aT(n/b)+f(n)$
        \item Master Theorem: Analyze divide-and-conquer recurrences
        \item Generating Functions: Convert recursions to algebraic form
        \item Asymptotic Analysis: Big-O analysis of recursive algorithms
        \item Recursion Trees: Visual method for analyzing complexity
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{C++ Recursion:}
    \begin{itemize}
        \item Stack Size: Default stack size limitations
        \item Inline Functions: Compiler optimizations for simple recursions
        \item Template Recursion: Compile-time recursive computations
        \item Exception Handling: Stack unwinding in recursive functions
        \item Memory Management: Automatic vs manual memory management
    \end{itemize}

    \item \textbf{Python Recursion:}
    \begin{itemize}
        \item Recursion Limit: \texttt{sys.setrecursionlimit()} for deep recursion
        \item Function Decorators: \texttt{@lru\_cache} for automatic memoization
        \item Generator Functions: \texttt{yield} for memory-efficient recursion
        \item Tail Call: Python doesn't optimize tail calls
        \item Exception Handling: \texttt{RecursionError} for stack overflow
    \end{itemize}
\end{itemize}
\section{Recursion-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead
\hline
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Palindrome Check (Recursion) & $\mathcal{O}(n)$ & Check first and last chars, recurse on substring. & Use 2-pointer recursive technique. & Empty or single char string \\
\hline
Count Set Bits from 1 to N & $\mathcal{O}(\log N)$ & Recursively count set bits using patterns in binary. & Use most significant bit position. & N = 0 or power of 2 \\
\hline
Rope Cutting Problem & $\mathcal{O}(3^n)$ & Try all 3 cuts recursively, take max of all valid. & Use memoization to avoid recomputation. & Cut lengths not possible \\
\hline
Generate Subsets & $\mathcal{O}(2^n)$ & For each element, include or exclude recursively. & Use backtracking to store current subset. & Empty set, duplicate elements \\
\hline
No. of Subsets with Given Sum (Recursive) & $\mathcal{O}(2^n)$  & Try including/excluding current element recursively. & Use DP or memoization. & Negative numbers, sum = 0 \\
\hline
Tower of Hanoi & $\mathcal{O}(2^n)$ & Move n-1 disks to aux, nth to target, then n-1 to target. & Direct formula: $2^n - 1$ moves. & n = 1, source = destination \\
\hline
Josephus Problem & $\mathcal{O}(n)$ & Use recursive relation $J(n, k) = (J(n-1, k) + k) \% n$. & Convert to 0-based index for clean recursion. & k = 1, n = 1 \\
\hline
Printing All Permutations & $\mathcal{O}(n!)$ & Swap elements recursively and backtrack. & Use visited[] or backtracking for non-repetition. & Duplicate elements \\
\hline
Permutations with Duplicates & $O(n!)$ & Sort input, use visited[] and skip same element at same level & Backtracking with used set check & All elements same \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/recursion}
\newgeometry{margin=0.2in}
\clearpage
\section{BackTracking-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead
\hline
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Rat in a Maze & $O(4^{n^2})$ & Move in 4 directions recursively, mark visited, backtrack. & Use visited matrix to avoid loops. & Blocked start/end, multiple paths \\
\hline
N-Queen Problem & $O(n!)$ & Try placing a queen in each row, backtrack if conflict. & Use hash arrays for column, diagonal tracking. & n = 2 or 3 (no solution) \\
\hline
Permutation without Forbidden Substring & $O(n!)$ & Generate all permutations, skip if forbidden substring found. & Prune permutations early during generation. & Forbidden string is entire string \\
\hline
Sudoku Solver & $O(9^{m})$ & Try placing digits 1-9 in empty cells, backtrack on conflict. & Track row, col, block constraints with sets. & Multiple solutions or unsolvable grid \\
\hline
Combination Sum & $O(2^n)$ & Include/exclude current element recursively, allow reuse. & Sort input, skip duplicates, prune large candidates. & target = 0, duplicates in array \\
\hline
Generate Parentheses & $O(2^n)$ & Backtrack with open $<=$ close, generate only valid & Prune invalid branches early & All open or close used early \\
\hline
Subset Sum = K (Print All Subsets) & $O(2^n)$ & Backtrack with sum tracker, include/exclude path & Prune if current sum > K & Zero or repeated numbers \\
\hline
Combination Sum II & $O(2^n)$ & Backtrack with sort & skip duplicates: if $i > start$ and $arr[i]==arr[i-1]$ → skip & Target < smallest \\
\hline
Subset Sum II (All Unique Subsets) & $O(2^n)$ & Similar to power set, use sorting to skip duplicates & Avoid repeated subsets using backtrack + set & Duplicates in input \\
\hline
Palindrome Partitioning & $O(2^n)$ & Backtrack with isPalindrome(i, j), explore all cuts & Memoize isPalindrome(i, j) to optimize & Whole string is palindrome \\
\hline
M-Coloring of Graph & $O(m^n)$ & Try all colors for each vertex with DFS/backtrack, check valid assignment & Use adjacency list for fast check & No color possible (backtrack fails) \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/backtracking}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{45}{20}\selectfont \textcolor{headingcolor}{\bfseries DYNAMIC PROGRAMMING}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/dp.png}
\end{center}

\chapter{Essential Dynamic Programming Techniques}
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:dp}
\begin{itemize}[leftmargin=*]
    \item \textbf{Core Principles:}
    \begin{itemize}
        \item Optimal Substructure: Solution to problem contains optimal solutions to subproblems
        \item Overlapping Subproblems: Same subproblems are solved multiple times in naive recursion
        \item Memoization vs Tabulation: Top-down (recursive + cache) vs Bottom-up (iterative)
        \item State Definition: Clearly define what each DP state represents
        \item Base Cases: Identify the simplest cases that don't require further recursion
    \end{itemize}

    \item \textbf{DP Design Process:}
    \begin{itemize}
        \item Step 1: Identify if problem has optimal substructure
        \item Step 2: Define state variables and their meaning
        \item Step 3: Write recurrence relation
        \item Step 4: Identify base cases
        \item Step 5: Determine order of computation (for tabulation)
        \item Step 6: Optimize space if possible
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Linear DP:}
    \begin{itemize}
        \item Fibonacci Pattern: $dp[i] = dp[i-1] + dp[i-2]$
        \item House Robber Pattern: $dp[i] = \max(dp[i-1], dp[i-2] + arr[i])$
        \item Climbing Stairs: Ways to reach position $i$ from previous positions
        \item Maximum Subarray: Kadane's algorithm as DP problem
        \item Coin Change: Minimum coins needed for amount $i$
    \end{itemize}

    \item \textbf{Grid DP:}
    \begin{itemize}
        \item Path Counting: $dp[i][j] = dp[i-1][j] + dp[i][j-1]$
        \item Minimum Path Sum: $dp[i][j] = \min(dp[i-1][j], dp[i][j-1]) + grid[i][j]$
        \item Unique Paths with Obstacles: Handle blocked cells in path counting
        \item Dungeon Game: Work backwards from bottom-right to top-left
        \item Cherry Pickup: Two paths simultaneously through grid
    \end{itemize}

    \item \textbf{String DP:}
    \begin{itemize}
        \item Longest Common Subsequence: $dp[i][j]$ for strings up to position $i,j$
        \item Edit Distance: Minimum operations to transform one string to another
        \item Palindrome Problems: Check/count palindromic subsequences
        \item String Matching: Pattern matching with wildcards
        \item Word Break: Check if string can be segmented using dictionary
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Knapsack Variations:}
    \begin{itemize}
        \item 0/1 Knapsack: Each item can be taken at most once
        \item Unbounded Knapsack: Unlimited quantity of each item
        \item Bounded Knapsack: Limited quantity of each item
        \item Multiple Knapsack: Multiple knapsacks with different capacities
        \item Subset Sum: Special case where values equal weights
    \end{itemize}

    \item \textbf{Interval DP:}
    \begin{itemize}
        \item Matrix Chain Multiplication: Optimal parenthesization
        \item Palindrome Partitioning: Minimum cuts to make all palindromes
        \item Burst Balloons: Optimal order to burst balloons
        \item Optimal BST: Minimize search cost in binary search tree
        \item State: $dp[i][j]$ represents optimal solution for interval $[i,j]$
    \end{itemize}

    \item \textbf{Tree DP:}
    \begin{itemize}
        \item Subtree Problems: Each node's answer depends on its children
        \item Binary Tree Maximum Path Sum: Path can start/end at any node
        \item House Robber III: Rob houses arranged in binary tree
        \item Tree Diameter: Longest path between any two nodes
        \item Rerooting Technique: Compute answer for each node as root
    \end{itemize}

    \item \textbf{Digit DP:}
    \begin{itemize}
        \item Count Numbers with Property: Count numbers in range with specific digits
        \item State Parameters: Position, tight constraint, started flag
        \item Tight Constraint: Whether current prefix forces us to stay within bounds
        \item Leading Zeros: Handle numbers with different digit counts
        \item Sum of Digits: Problems involving digit sum constraints
    \end{itemize}

    \item \textbf{Bitmask DP:}
    \begin{itemize}
        \item Traveling Salesman: Visit all cities with minimum cost
        \item Assignment Problems: Assign tasks to workers optimally
        \item State Representation: Use bitmask to represent subset of items
        \item SOS DP: Sum over subsets dynamic programming
        \item Hamiltonian Path: Find path visiting all vertices exactly once
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Space Optimization:}
    \begin{itemize}
        \item Rolling Array: When current state depends only on previous row/column
        \item 1D to 2D Reduction: Reduce 2D DP to 1D when possible
        \item Coordinate Compression: When state space is sparse but large
        \item Memory Efficient: Process states in specific order to reuse memory
        \item Backwards Iteration: Sometimes needed to avoid overwriting needed values
    \end{itemize}

    \item \textbf{Time Optimization:}
    \begin{itemize}
        \item Matrix Exponentiation: For linear recurrences with large $n$
        \item Convex Hull Trick: Optimize DP with linear functions
        \item Divide and Conquer DP: When recurrence has specific monotonicity
        \item Knuth-Yao Optimization: For quadrilateral inequality problems
        \item Slope Trick: Represent DP function as piecewise linear
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{DP Indicators:}
    \begin{itemize}
        \item Optimization Problems: Find minimum/maximum value
        \item Counting Problems: Count number of ways to do something
        \item Decision Problems: Yes/No questions with subproblem structure
        \item Recursive Structure: Problem can be broken into similar subproblems
        \item Choices at Each Step: At each step, you make a choice affecting future
    \end{itemize}

    \item \textbf{When NOT to Use DP:}
    \begin{itemize}
        \item Greedy Suffices: When greedy choice leads to optimal solution
        \item No Overlapping Subproblems: If subproblems don't repeat
        \item Exponential State Space: When memoization table becomes too large
        \item Simple Math Formula: When closed-form solution exists
        \item Graph Problems: When BFS/DFS is more appropriate
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{State Variable Selection:}
    \begin{itemize}
        \item Position-based: Current position in array/string/grid
        \item Value-based: Current sum, product, or accumulated value
        \item Choice-based: What was the last choice made
        \item Constraint-based: Remaining capacity, budget, or limit
        \item Flag-based: Boolean flags for special conditions
    \end{itemize}

    \item \textbf{Multi-dimensional States:}
    \begin{itemize}
        \item 2D DP: Two changing parameters (position, remaining capacity)
        \item 3D DP: Three parameters (two strings + operation count)
        \item Bitmask States: When subset of items needs to be tracked
        \item State Compression: Combine multiple variables into single state
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Common Recurrence Types:}
    \begin{itemize}
        \item Addition: $dp[i] = dp[i-1] + dp[i-2]$ (Fibonacci-like)
        \item Minimum/Maximum: $dp[i] = \min/\max(dp[i-1] + cost, dp[i-2] + cost)$
        \item Multiplication: $dp[i] = dp[i-1] \times dp[i-2]$ (rare but exists)
        \item Conditional: Different recurrence based on current element
        \item Range-based: $dp[i] = \min_{j < i}(dp[j] + cost(j,i))$
    \end{itemize}

    \item \textbf{Boundary Conditions:}
    \begin{itemize}
        \item Base Cases: Define values for smallest valid inputs
        \item Invalid States: Handle states that shouldn't be reached
        \item Edge Cases: First/last elements often need special handling
        \item Initialization: Some states need non-zero initial values
        \item Sentinels: Use dummy values to simplify boundary checking
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Implementation Strategie Top-Down (Memoization):}
    \begin{itemize}
        \item Recursive Function: Write natural recursive solution first
        \item Memoization Table: Cache results to avoid recomputation
        \item Parameter Mapping: Map function parameters to array indices
        \item Return vs Reference: Decide whether to return value or modify reference
        \item Stack Overflow: Watch out for deep recursion limits
    \end{itemize}

    \item \textbf{Bottom-Up (Tabulation):}
    \begin{itemize}
        \item Iteration Order: Ensure dependencies are computed before use
        \item Array Initialization: Initialize DP table with appropriate values (Generally reverse of recursive calls)
        \item Loop Structure: Nested loops for multi-dimensional DP (bottom-up)
        \item State Transitions: Implement recurrence relation in loops(usually same as recursive version)
        \item Final Answer: Extract answer from appropriate DP state(by which recursion was called)
    \end{itemize}
\end{itemize}
\begin{itemize}[leftmargin=*]
    \item \textbf{DP-Specific Debugging:}
    \begin{itemize}
        \item Small Test Cases: Start with minimal input size
        \item Base Case Verification: Ensure base cases are correct
        \item State Printing: Print DP table to visualize computation
        \item Recurrence Checking: Manually verify few state transitions
        \item Boundary Testing: Test edge cases thoroughly
    \end{itemize}

    \item \textbf{Common DP Mistakes:}
    \begin{itemize}
        \item Wrong State Definition: State doesn't capture all necessary information
        \item Incorrect Base Cases: Base cases don't match problem requirements
        \item Order Dependency: Computing states before their dependencies
        \item Index Errors: Off-by-one errors in array indexing
        \item Overflow Issues: Integer overflow in intermediate calculations
    \end{itemize}
\end{itemize}
\begin{itemize}[leftmargin=*]
    \item \textbf{Problem Analysis:}
    \begin{itemize}
        \item Constraint Analysis: Use constraints to estimate DP table size
        \item Pattern Recognition: Quickly identify known DP patterns
        \item Brute Force First: Start with recursive solution, then optimize
        \item State Space Estimation: Calculate memory requirements early
        \item Time Complexity: Estimate time complexity from state count
    \end{itemize}

    \item \textbf{Implementation Speed:}
    \begin{itemize}
        \item Template Preparation: Have templates for common DP patterns
        \item Macro Usage: Define macros for loop structures and common operations
        \item Fast I/O: Use fast input/output for large datasets
        \item Memory Declaration: Declare DP arrays globally to avoid stack overflow
        \item Code Reuse: Adapt similar problem solutions when possible
    \end{itemize}

    \item \textbf{Problem Variants:}
    \begin{itemize}
        \item Path Reconstruction: Sometimes you need to find actual solution, not just value
        \item Multiple Queries: Precompute DP table for answering multiple queries
        \item Online DP: Handle dynamic updates to input
        \item Probability DP: Expected value calculations using DP
        \item Game Theory DP: Minimax problems with optimal play
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Mathematical Optimization:}
    \begin{itemize}
        \item Lagrange Multipliers: For constrained optimization problems
        \item Generating Functions: Convert DP recurrence to algebraic form
        \item Linear Programming: When DP can be formulated as LP
        \item Probability Theory: For expected value DP problems
        \item Combinatorics: For counting problems with DP
    \end{itemize}

    \item \textbf{Data Structure Integration:}
    \begin{itemize}
        \item Segment Trees: For range query DP optimizations
        \item Binary Indexed Trees: For efficient range sum updates
        \item Priority Queues: For maintaining optimal choices
        \item Deque Optimization: For sliding window DP problems
        \item Hash Tables: For state compression and memoization
    \end{itemize}
\end{itemize}


\section{Dynamic Programming-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Binomial Coefficient & $O(nk)$ & $C(n, k) = C(n-1, k-1) + C(n-1, k)$ & Use 1D array for space optimization. & k = 0 or k = n \\
\hline
Minimum Jumps to Reach End & $O(n^2)$ & $dp[i] = \min(dp[j] + 1)$ for all $j$ where $j + arr[j] \geq i$ & Greedy + DP for faster solution. & 0 at start, unreachable end \\
\hline
Longest Increasing Subsequence & $O(n^2)$ or $O(n \log n)$ & $dp[i] = \max(dp[j] + 1)$ for all $j < i$ and $arr[j] < arr[i]$ & Use Binary Search for $O(n \log n)$ & Strict vs non-strict LIS \\
\hline
Longest Increasing Subsequence (LIS) in $O(n \log n)$ & $O(n \log n)$ & Maintain tail array, use binary search to find correct position of current element & Patience sorting idea; track indices for printing LIS & All decreasing or equal elements \\
\hline
Number of Longest Increasing Subseq. & $O(n^2)$ & Track length and count arrays; update both while scanning & Count ways for each LIS length & All elements same \\
\hline
Print All LIS & $O(n^2)$ & DP for LIS + backtrack all paths matching LIS length & Use memoized backtracking tree & Multiple LIS of same length \\
\hline
Longest Divisible Subset & $O(n^2)$ & Sort + apply DP if $a \% b == 0$ or $b \% a == 0$ & Maintain prev index for reconstruction & All primes or no pair \\
\hline
Minimum Deletions to Make Array Sorted & $O(n^2)$ & $n - \text{LIS}(arr)$ is answer & Use LIS DP for longest sorted subarray & Already sorted or all same \\
\hline
Maximum Sum Increasing Subsequence & $O(n^2)$ & Replace LIS length DP with sum DP & Track current sum, not length & All elements negative \\
\hline
Maximum Length Bitonic Subsequence & $O(n^2)$ & Compute LIS from left, LDS from right; combine & $bitonic[i] = LIS[i] + LDS[i] - 1$ & All increasing or decreasing \\
\hline
Building Bridges (Max Bridges without Crossing) & $O(n \log n)$ & Sort by one coordinate, apply LIS on other & Classic LIS in disguise & Same x or y coordinate \\
\hline
Stack of Boxes (W, H, D) & $O(n^2)$ & Sort boxes by dimension; LIS on valid stackable boxes & Memoize max height for each box as base & Boxes with same dimensions \\
\hline
0-1 Knapsack & $O(nW)$ & $dp[i][w] = \max(dp[i-1][w], val[i] + dp[i-1][w-wt[i]])$ & Use 1D DP with reverse loop. & Zero capacity or no items \\
\hline
Subset Sum & $O(n \cdot sum)$ & $dp[i][j] = dp[i-1][j]$ or $dp[i-1][j - arr[i]]$ & Use 1D boolean DP array in reverse loop (s to a[i]) & sum = 0 or negative numbers \\
\hline
Equal Sum Partition & $O(n \cdot sum)$ & Reduce to Subset Sum with $sum/2$ & Return false if total sum is odd & Odd total sum \\
\hline
Count of Subsets with Given Sum & $O(n \cdot sum)$ & $dp[i][j] = dp[i-1][j] + dp[i-1][j - arr[i]]$ & Use 1D array for space, modulo if needed & sum = 0 or duplicates \\
\hline
Minimum Subset Sum Difference & $O(n \cdot sum)$ & Subset Sum variation: find closest sum $\leq \text{total}/2$ & Track all reachable subset sums & All elements equal or one element \\
\hline
Target Sum(Number of subset with given difference) & $O(n \cdot sum)$ & Count subsets with sum = $(S + total)/2$ & Convert to subset sum count problem & S > total sum or not integer \\
\hline

Longest Common Subsequence & $O(nm)$ & $dp[i][j] = dp[i-1][j-1]+1$ if match else $\max(dp[i-1][j], dp[i][j-1])$ & Use only two rows for space. & One string empty \\
\hline
Printing LCS & $O(nm)$ & Backtrack from $dp[n][m]$ while building string from bottom right move diagonally if matches if not max of top or left & Use reverse of backtracking path & Multiple LCS of same length \\
\hline
Difference Utility (Min Insert + Delete) & $O(nm)$ & LCS-based: Insertions = $m - \text{LCS}$, Deletions = $n - \text{LCS}$ & Use 1D DP if only lengths needed. & One string empty \\
\hline
Minimum Insertions and Deletions to Convert & $O(nm)$ & Same as above: Use LCS of $s1$, $s2$ & Optimize insert/delete count together & Identical strings \\
\hline
Shortest Common Supersequence & $O(nm)$ & $len(SCS) = n + m - \text{LCS}$ & Use LCS table to reconstruct SCS. & One string empty \\
\hline
Print SCS & $O(n \cdot m)$ & Use LCS to reconstruct: if same take once, else take from where max(dp) & Backtrack from LCS table & Empty strings \\
\hline
Longest Repeating Subsequence & $O(n^2)$ & LCS of string with itself, but $i \neq j$ & Modify LCS DP to skip same index match & All characters same or none repeated \\
\hline
Longest Repeating Substring (DP) & $O(n^2)$ & LCS with same string, but $i \neq j$: \newline $dp[i][j] = dp[i-1][j-1]+1$ if $s[i]=s[j]$ & Track max length only & All distinct characters \\
\hline
Longest Palindromic Subsequence & $O(n^2)$ & LCS of string with its reverse & Use standard LCS on $s$ and $rev(s)$ & Palindromic or single character string \\
\hline

Length of Largest Subsequence of A which is Substring in B & $O(n \cdot m)$ & DP where $dp[i][j] = dp[i-1][j-1]+1$ if $a[i]=b[j]$ else 0, track max & Reset if mismatch & Subsequence order mismatch \\
\hline
Subsequence Pattern Matching(if a is present in b) & $O(n \cdot m)$ & Count ways $dp[i][j] = dp[i-1][j-1] + dp[i][j-1]$ if match else $dp[i][j-1]$ & 1D array if needed (len(LPS)==len(a) is sufficient)& a empty, multiple matches \\
\hline
Count of Subsequences of a in b & $O(n \cdot m)$ & Same as above; treat a as pattern and b as text & Initialize first row with 1s (can be done using just 1 1D array) & a longer than b \\
\hline
Longest Palindromic Substring & $O(n^2)$ & $dp[i][j] = true$ if $s[i] = s[j]$ and $dp[i+1][j-1]$ is true & Expand from center for $O(n^2)$ & All same char, length = 1 \\
\hline
Count of Palindromic Substrings & $O(n^2)$ & Count all $(i,j)$ where $s[i..j]$ is palindrome via DP or expand method & Expand around center is simpler & Single chars count too \\
\hline
Minimum Insertions to Make Palindrome & $O(n^2)$ & $dp[i][j] = dp[i+1][j-1]$ if match else $1 + \min(dp[i+1][j], dp[i][j-1])$ & Convert to LPS: $n - LPS$ & Already a palindrome \\
\hline
Minimum Deletions to Make Palindrome & $O(n^2)$ & $n - \text{LPS}(s)$ where LPS = LCS(s, rev(s)) & Use LCS with reverse string & All characters distinct \\
\hline
Edit Distance & $O(nm)$ & $dp[i][j] = 1 + \min(\text{insert, remove, replace})$ & 2 rows only needed. & One string empty \\
\hline
Optimal Strategy for Game (Choose boundary) & $O(n^2)$ & $dp[i][j] = \max(\text{val}_i + \min(dp[i+2][j], dp[i+1][j-1]),\; \text{val}_j + \min(dp[i][j-2], dp[i+1][j-1]))$ & Fill diagonally using gap method & One or two elements only \\
\hline
Count BSTs with $n$ Keys (Catalan Number) & $O(n^2)$ & $dp[n] = \sum_{i=0}^{n-1} dp[i] \cdot dp[n-1-i]$ & Use closed-form: $C_n = \frac{1}{n+1} \binom{2n}{n}$ for large $n$ & $n = 0$ or $n = 1$ \\
\hline
Max Sum with No Two Consecutive & $O(n)$ & $dp[i] = \max(dp[i-1], arr[i] + dp[i-2])$ & 2 variables (prev, prev2) instead of array & Negative numbers \\
\hline
Allocate Minimum Pages & $O(n \cdot k \cdot \log(sum(pages[])$ & Binary search on answer + greedy check if allocation is feasible with mid pages & Minimize max load among partitions & Pages $>$ total or students $>$ books \\
\hline
Unbounded Knapsack & $O(n \cdot W)$ & $dp[i][j] = \max(dp[i-1][j], val[i] + dp[i][j - wt[i]])$ & Use 1D array (forward loop on $j$) & All weights $>$ capacity \\
\hline
Rod Cutting Problem & $O(n \cdot n)$ & $dp[i][j] = \max(dp[i-1][j], price[i-1] + dp[i][j-i])$ & Identical to unbounded knapsack & Length not divisible \\
\hline
Coin Change (Total Ways) & $O(n \cdot sum)$ & $dp[i][j] = dp[i-1][j] + dp[i][j - coin]$ & 1D array suffices using forward loop & No solution or coin = 1 only \\
\hline
Maximum Cuts & $O(n)$ & $dp[i] = \max(dp[i-x], dp[i-y], dp[i-z]) + 1$ if valid & Initialize with -1 to track impossible. & No valid cuts \\
\hline
Minimum Coins to Make Value & $O(n \cdot sum)$ & $dp[i] = \min(dp[i], dp[i-coin] + 1)$ & Use INT\_MAX-1 to avoid overflow. & Value can’t be made \\
Matrix Chain Multiplication (MCM) & $O(n^3)$ & $dp[i][j] = \min_{k=i}^{j-1}(dp[i][k] + dp[k+1][j] + cost)$ & Use gap-based diagonal filling & No matrix to multiply or one matrix \\
\hline
Printing MCM & $O(n^3)$ & Same as MCM, maintain a `bracket[][]` matrix to track $k$ & Recursively print brackets from matrix & Optimal split at multiple $k$ \\
\hline
Boolean Parenthesization (Evaluate to True) & $O(n^3)$ & $T[i][j] = \sum_k$ ways with op, combine true/false & Memoize $(i,j,True/False)$ state & All True or all False cases \\
\hline
Min/Max Value of Expression & $O(n^3)$ & $dp[i][j] = \min/\max$ over all $k$: combine left and right based on operator & Maintain min/max matrices separately & Operator only one type \\
\hline
Palindrome Partitioning (Min Cuts) & $O(n^3)$ & $dp[i][j] = 0$ if palindrome, else $\min_{k=i}^{j-1}(dp[i][k] + dp[k+1][j] + 1)$ & Precompute isPalindrome table & Already palindrome string \\
\hline
Palindrome Partitioning (Min Cuts) & $O(n^2)$ & Instead of calculating dp[i] separately we can do it with the $P[j][i]$ itself & Precompute isPalindrome table & Already palindrome string \\
\hline
Egg Dropping Puzzle & $O(n \cdot k^2)$ & $dp[e][f] = \min_{x=1}^{f} (1 + \max(dp[e-1][x-1], dp[e][f-x]))$ & Use binary search on floor for $O(n \cdot k \log k)$ & 1 egg or 1 floor \\
\hline
Buy \& Sell Stock II (Infinite Tx) & $O(n)$ & Greedy: sum of all positive differences & Track only increasing slopes & Always decreasing prices \\
\hline
Buy \& Sell Stock IV (At most K Tx) & $O(k \cdot n)$ & $dp[i][j] = \max(dp[i][j-1], prices[j] - min)$ & Use 1D DP if optimizing space & k > n/2 acts as infinite tx \\
\hline
Buy \& Sell with Cool Down & $O(n)$ & 3 states: hold, sold, cooldown; recurrence from prev day & Use rolling vars instead of arrays & Cooldown on 1st day \\
\hline
Buy \& Sell with Transaction Fee & $O(n)$ & State: hold or cash; use recurrence on transition with fee & Linear scan with 2 variables & Fee > all profit \\
\hline

Min Cost to Cut Stick & $O(n^3)$ & Add 0 and len, sort cuts → DP: \newline $dp[i][j] = \min(dp[i][j], dp[i][k] + dp[k][j] + cost)$ & Memoize overlapping intervals & No cuts or cuts at ends \\
\hline
isPalindrome(i,j) Preprocessing & $O(n^2)$ & $dp[i][j] = s[i] == s[j] \land dp[i+1][j-1]$ & Precompute and use in partitioning & Single character or empty \\
\hline
Palindrome Partitioning II & $O(n^2)$ & DP + isPalindrome table: \newline $dp[i] = \min(dp[j-1]+1)$ if $s[j..i]$ palindrome & Precompute isPalindrome(i,j) & Already a full palindrome \\
\hline
Count Squares in Binary Matrix & $O(nm)$ & $dp[i][j] = 1 + \min(top, left, diag)$ if cell = 1 & Add all dp[i][j] for total count & Isolated 1s \\
\hline
Balloon Burst (Min/Max Coins) & $O(n^3)$ & DP on interval: \newline $dp[i][j] = \max(dp[i][k] + nums[i]*nums[k]*nums[j] + dp[k][j])$ & Add dummy 1s at ends & Only 1 balloon \\
\hline
Book Allocation Problem (DP) & $O(n^2 \cdot k)$ & $dp[i][j] = \min_{p<i}(\max(dp[p][j-1], sum(p+1..i)))$ & Use prefix sums, try binary search on answer for greedy version & Books > students or large books first \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/dp}
\newgeometry{margin=0.2in}
\vspace*{47mm}

\begin{center}

{\fontsize{55}{20}\selectfont \textcolor{headingcolor}{\bfseries GRAPHS}}
\end{center}

\vspace{50mm}

\begin{center}
\includegraphics[height=13.88cm, width=17cm, keepaspectratio]{Pics/graph.png}
\end{center}

\chapter{Essential Graph Techniques}
\phantomsection                      % <-- creates a hyperlink anchor
\label{sec:graph}
\begin{itemize}[leftmargin=*]
    \item \textbf{Graph Representation:}
    \begin{itemize}
        \item Adjacency List: Best for sparse graphs, $O(V + E)$ space, efficient iteration
        \item Adjacency Matrix: Best for dense graphs, $O(V^2)$ space, $O(1)$ edge lookup
        \item Edge List: Simple representation, good for sorting edges by weight
        \item Implicit Graphs: Grid problems, state-space graphs, tree-like structures
        \item Weighted vs Unweighted: Choose appropriate algorithms based on edge weights
    \end{itemize}

    \item \textbf{Graph Types Recognition:}
    \begin{itemize}
        \item Directed vs Undirected: Affects algorithm choice and implementation
        \item Cyclic vs Acyclic: DAGs enable topological sorting and DP
        \item Connected vs Disconnected: May need to handle multiple components
        \item Bipartite Graphs: Special properties for matching and coloring
        \item Trees: $V-1$ edges, no cycles, special algorithms available
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Core Traversal Algorithms : Depth-First Search (DFS):}
    \begin{itemize}
        \item Connected Components: Count and identify connected regions
        \item Cycle Detection: In both directed and undirected graphs
        \item Topological Sorting: For DAGs using DFS finishing times
        \item Bridge Finding: Critical edges whose removal disconnects graph
        \item Articulation Points: Critical vertices whose removal disconnects graph
        \item Path Finding: Find any path between two vertices
        \item Tree Traversal: Preorder, inorder, postorder patterns
    \end{itemize}

    \item \textbf{Breadth-First Search (BFS):}
    \begin{itemize}
        \item Shortest Path: In unweighted graphs, guarantees minimum hops
        \item Level-Order Traversal: Process nodes level by level
        \item Bipartite Check: Color graph with two colors using BFS
        \item Multi-Source BFS: Start from multiple sources simultaneously
        \item 0-1 BFS: For graphs with 0 and 1 weight edges using deque
        \item Grid Problems: Flood fill, shortest path in maze
    \end{itemize}

    \item \textbf{Advanced Traversal Techniques:}
    \begin{itemize}
        \item Bidirectional BFS: Meet-in-the-middle for shortest path
        \item Iterative Deepening: DFS with increasing depth limits
        \item A* Search: Heuristic-guided search for shortest path
        \item Dijkstra's Algorithm: Shortest path in weighted graphs
        \item Bellman-Ford: Handle negative weights, detect negative cycles
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Single Source Shortest Path:}
    \begin{itemize}
        \item BFS: Unweighted graphs, $O(V + E)$ time complexity
        \item Dijkstra: Non-negative weights, $O((V + E) \log V)$ with priority queue
        \item Bellman-Ford: Handles negative weights, $O(VE)$ time, detects negative cycles
        \item SPFA: Optimized Bellman-Ford using queue, average case faster
        \item 0-1 BFS: Only 0 and 1 weights, $O(V + E)$ using deque
    \end{itemize}

    \item \textbf{All Pairs Shortest Path:}
    \begin{itemize}
        \item Floyd-Warshall: $O(V^3)$ DP algorithm, handles negative weights
        \item Johnson's Algorithm: $O(V^2 \log V + VE)$ for sparse graphs
        \item Matrix Exponentiation: For unweighted graphs with large path lengths
        \item Repeated Dijkstra: Run from each vertex for non-negative weights
    \end{itemize}

    \item \textbf{Shortest Path Variants:}
    \begin{itemize}
        \item K-Shortest Paths: Find multiple shortest paths between vertices
        \item Constrained Shortest Path: With additional constraints (time, capacity)
        \item Shortest Path Tree: Tree of shortest paths from source to all vertices
        \item Path Reconstruction: Backtrack to find actual shortest path
        \item Dynamic Shortest Path: Handle edge weight updates efficiently
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{MST Algorithms:}
    \begin{itemize}
        \item Kruskal's Algorithm: Sort edges, use Union-Find, $O(E \log E)$
        \item Prim's Algorithm: Grow tree from vertex, $O(E \log V)$ with priority queue
        \item Borůvka's Algorithm: Parallel MST construction, good for dense graphs
        \item Algorithm Selection: Kruskal for sparse, Prim for dense graphs
    \end{itemize}

    \item \textbf{MST Applications:}
    \begin{itemize}
        \item Network Design: Minimum cost to connect all nodes
        \item Clustering: Remove heaviest edges to create clusters
        \item Approximation Algorithms: TSP approximation using MST
        \item Bottleneck MST: Minimize maximum edge weight in spanning tree
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Strongly Connected Components:}
    \begin{itemize}
        \item Kosaraju's Algorithm: Two DFS passes, $O(V + E)$ time
        \item Tarjan's Algorithm: Single DFS with low-link values
        \item SCC Condensation: Create DAG from SCCs for further processing
        \item 2-SAT Problem: Reduce to SCC finding in implication graph
    \end{itemize}

    \item \textbf{Topological Sorting:}
    \begin{itemize}
        \item Kahn's Algorithm: BFS-based using in-degree counting
        \item DFS-Based: Use finishing times from DFS traversal
        \item Cycle Detection: No topological order exists if cycle present
        \item Applications: Task scheduling, dependency resolution, course prerequisites
        \item Lexicographic Order: Smallest lexicographic topological order
    \end{itemize}

    \item \textbf{Network Flow:}
    \begin{itemize}
        \item Ford-Fulkerson: Basic max flow using DFS path finding
        \item Edmonds-Karp: BFS-based, $O(VE^2)$ time complexity
        \item Dinic's Algorithm: Efficient max flow, $O(V^2E)$ general, $O(E^{1.5})$ for unit capacity
        \item Min-Cut Max-Flow: Duality between maximum flow and minimum cut
        \item Bipartite Matching: Reduce to max flow problem
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Tree Traversal and Properties:}
    \begin{itemize}
        \item Tree Diameter: Longest path between any two nodes
        \item Tree Center: Node(s) that minimize maximum distance to all other nodes
        \item Lowest Common Ancestor: LCA using binary lifting or RMQ
        \item Tree Isomorphism: Check if two trees have same structure
        \item Heavy-Light Decomposition: Decompose tree into heavy and light edges
    \end{itemize}

    \begin{itemize}
        \item Subtree DP: Each node's value depends on its subtree
        \item Rerooting DP: Compute answer for each node as root
        \item Path Queries: Answer queries about paths in tree
        
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Bipartite Graphs:}
    \begin{itemize}
        \item Bipartite Matching: Maximum matching using augmenting paths
        
        \item Bipartite Coloring: 2-coloring using BFS/DFS
        \item Stable Marriage: Assign pairs with stable preferences
    \end{itemize}

    \item \textbf{Planar Graphs:}
    \begin{itemize}
        \item Euler's Formula: $V - E + F = 2$ for connected planar graphs
        \item Planarity Testing: Check if graph can be drawn without edge crossings
        \item Face Traversal: Navigate faces in planar graph embedding
        \item Dual Graph: Construct dual of planar graph
    \end{itemize}
\end{itemize}
\begin{itemize}[leftmargin=*]
    \item \textbf{Grid Graph Problems:}
    \begin{itemize}
        \item Flood Fill: Connected component finding in grid
        \item Island Counting: Count connected regions of same type
        \item Shortest Path in Grid: BFS for unweighted, Dijkstra for weighted
        \item Grid Coloring: Ensure adjacent cells have different colors
        \item Multi-dimensional Grids: Extend algorithms to 3D+ grids
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Graph Coloring:}
    \begin{itemize}
        \item Bipartite Coloring: 2-coloring for bipartite graphs
        \item Greedy Coloring: Simple heuristic for general graphs
        \item Welsh-Powell Algorithm: Order vertices by degree for coloring
        \item Chromatic Number: Minimum colors needed (NP-hard in general)
        \item Edge Coloring: Color edges so adjacent edges have different colors
    \end{itemize}

    \item \textbf{Independent Sets and Cliques:}
    \begin{itemize}
        \item Maximum Independent Set: Largest set of non-adjacent vertices
        \item Maximum Clique: Largest complete subgraph
        \item Vertex Cover: Minimum set of vertices covering all edges
        \item Complement Relationship: Independent set in G = clique in complement
        \item Tree Independent Set: DP solution for trees
    \end{itemize}
\end{itemize}
\begin{itemize}[leftmargin=*]
    \item \textbf{When to Use Different Algorithms:}
    \begin{itemize}
        \item BFS: Shortest path in unweighted graphs, level-order problems
        \item DFS: Connectivity, cycle detection, topological sort
        \item Dijkstra: Shortest path with non-negative weights
        \item Bellman-Ford: Negative weights possible, detect negative cycles
        \item Floyd-Warshall: All-pairs shortest path, small graphs
        \item Union-Find: Dynamic connectivity, MST algorithms
    \end{itemize}

    \item \textbf{Problem Type Identification:}
    \begin{itemize}
        \item Pathfinding: Shortest/longest path between vertices
        \item Connectivity: Check if vertices are connected, count components
        \item Ordering: Topological sort, scheduling problems
        \item Optimization: MST, maximum flow, minimum cut
        \item Matching: Bipartite matching, assignment problems
        \item Coloring: Resource allocation, conflict resolution
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Data Structure Choices:}
    \begin{itemize}
        \item Vector of Vectors: Most common for adjacency lists
        \item Array of Vectors: When vertex count is known and reasonable
        \item HashMap: When vertices are not consecutive integers
        \item Priority Queue: For Dijkstra, Prim’s algorithm
        \item Deque: For 0-1 BFS optimization
        \item Union-Find: For connectivity and MST problems
    \end{itemize}

    \item \textbf{State Management:}
    \begin{itemize}
        \item Visited Arrays: Track visited vertices in traversal
        \item Distance Arrays: Store shortest distances from source
        \item Parent Arrays: Reconstruct paths after algorithms
        \item Color Arrays: For bipartite checking and graph coloring
        \item Time Stamps: DFS start/finish times for advanced algorithms
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Time Complexity Improvements:}
    \begin{itemize}
        \item Early Termination: Stop when target found or condition met
        \item Bidirectional Search: Meet-in-the-middle for shortest path
        \item Heuristic Search: A* with good heuristic function
        \item Preprocessing: Precompute information for multiple queries
        \item Data Structure Optimization: Use appropriate data structures
    \end{itemize}

    \item \textbf{Space Optimization:}
    \begin{itemize}
        \item Implicit Graph Representation: Generate edges on-the-fly
        \item Coordinate Compression: Map large coordinate space to smaller one
        \item Bit Manipulation: Use bits for boolean arrays when appropriate
        \item In-place Algorithms: Modify input graph instead of creating new structures
        \item Streaming Algorithms: Process large graphs with limited memory
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Implementation Mistakes:}
    \begin{itemize}
        \item Off-by-One Errors: Incorrect indexing in adjacency lists/matrices
        \item Uninitialized Arrays: Forgetting to initialize visited/distance arrays
        \item Integer Overflow: Large distance calculations in shortest path
        \item Stack Overflow: Deep recursion in DFS for large graphs
        \item Memory Limit: Large adjacency matrices for dense graphs
    \end{itemize}

    \item \textbf{Edge Cases to Consider:}
    \begin{itemize}
        \item Empty Graph: No vertices or edges
        \item Single Vertex: Graph with only one vertex
        \item Disconnected Graph: Multiple connected components
        \item Self Loops: Edges from vertex to itself
        \item Multiple Edges: More than one edge between same pair of vertices
        \item Negative Weights: Special handling required
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Problem Analysis:}
    \begin{itemize}
        \item Constraint Analysis: Use constraints to choose appropriate algorithm
        \item Graph Size: $|V|$ and $|E|$ determine feasible time complexity
        \item Weight Ranges: Affect choice between different shortest-path algorithms
        \item Query Types: Multiple queries may need preprocessing
        \item Memory Limits: Consider space complexity of chosen approach
    \end{itemize}

    \item \textbf{Implementation Speed:}
    \begin{itemize}
        \item Template Library: Prepare templates for common algorithms
        \item Macro Definitions: Define macros for frequently used constructs
        \item Fast I/O: Use fast input/output for large graphs
        \item Standard Library: Leverage STL containers and algorithms
        \item Code Reuse: Adapt solutions from similar problems
    \end{itemize}

    \item \textbf{Testing Strategies:}
    \begin{itemize}
        \item Small Examples: Test with hand-traced small graphs
        \item Edge Cases: Test disconnected graphs, single vertices
        \item Large Inputs: Stress test with maximum constraints
        \item Visual Debugging: Draw small graphs to verify correctness
        \item Known Algorithms: Compare with standard library implementations
    \end{itemize}
\end{itemize}

\begin{itemize}[leftmargin=*]
    \item \textbf{Approximation Algorithms:}
    \begin{itemize}
        \item TSP Approximation: 2-approximation using MST
        \item Vertex Cover Approximation: 2-approximation using maximal matching
        \item Set Cover: Greedy approximation for covering problems
        \item Graph Partitioning: Approximate solutions for NP-hard partitioning
    \end{itemize}

    \item \textbf{Randomized Algorithms:}
    \begin{itemize}
        \item Random Walk: Explore graph using random decisions
        \item Monte Carlo Methods: Random sampling for graph properties
        \item Randomized Connectivity: Efficient connectivity testing
    \end{itemize}
\end{itemize}
\section{Graph-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Breadth First Traversal (BFS) & $O(V + E)$ & Use queue, mark visited, explore neighbors level-wise & Use visited[] to avoid revisits & Disconnected graph \\
\hline
Depth First Traversal (DFS) & $O(V + E)$ & Recursively visit unvisited neighbors via stack or call stack & Track visited[] carefully & Cycles or multiple components \\
\hline
Shortest Path in Unweighted Graph & $O(V + E)$ & BFS from source, maintain distance[] & Use simple queue (not priority) & Disconnected nodes \\
\hline
Shortest Path in DAG (Topo Sort) & $O(V + E)$ & Topo sort, then relax edges in order of topological sort & Initialize distance[src] = 0 & Negative weights allowed (but no cycles) \\
\hline

Detect Cycle in Undirected Graph & $O(V + E)$ & DFS with parent tracking; if visited \& not parent, cycle exists & Use union-find for optimization & Multiple components \\
\hline
Detect Cycle in Directed Graph (DFS) & $O(V + E)$ & DFS with recursion stack[] to detect back edge & Maintain visited[] and recStack[] & Self-loops, multiple paths \\
\hline
Cycle Detection (Directed, BFS - Kahn’s Algo) & $O(V + E)$ & If topological sort includes fewer than $V$ nodes → cycle exists & Count in-degree processed & No zero in-degree node initially \\
\hline
Cycle Detection (Undirected, BFS) & $O(V + E)$ & BFS with parent tracking; same as DFS logic in BFS form & Use queue to traverse components & Self-loop \\
\hline
Topological Sorting (Kahn's Algo) & $O(V + E)$ & Use in-degree[] array and queue, remove 0-in-degree nodes iteratively & Detect cycle if count != V & Cycle (no topo sort) \\
\hline
Dijkstra’s Algorithm (Min Path in Weighted Graph) & $O((V + E) \log V)$ & Priority queue + distance[], greedy approach & Use set or min-heap & Negative weights not allowed \\
\hline
Prim’s Algorithm (MST) & $O((V + E) \log V)$ & Similar to Dijkstra; choose edge with min cost connecting tree & Use min-heap for edges & Disconnected graph \\
\hline
Kosaraju’s Algorithm (SCC - Directed) & $O(V + E)$ & 2 DFS passes: finish stack, then reverse graph & Use stack to record finish order & No strongly connected pairs \\
\hline
SCC Count in Undirected Graph & $O(V + E)$ & Use DFS/BFS; each traversal = new component & Track visited[] carefully & Fully connected = 1 component \\
\hline
Bellman-Ford (Min Path with Neg Weights) & $O(V \cdot E)$ & Relax all edges V-1 times, check for -ve cycles in Vth pass & Detect negative cycle separately & -ve weight cycle reachable \\
\hline
Floyd-Warshall (All Pair Shortest Paths) & $O(V^3)$ & $dist[i][j] = \min(dist[i][j], dist[i][k] + dist[k][j])$ for all $k$ & Update in-place if needed, handle self-loops carefully & Negative cycles \\
\hline
Articulation Points (Cut Vertices) & $O(V + E)$ & DFS + low[] and disc[] tracking; check if subtree can't reach ancestor & Root special case (multiple children) & Tree edges vs back edges \\
\hline
Bridges in Graph & $O(V + E)$ & DFS with discovery \& low[]; if low[v] $>$ disc[u], (u,v) is bridge & Track visited \& parent correctly & Multiple components \\
\hline
Disjoint Set - Find & $O(\alpha(n))$ & Recursively find parent of a node & Use path compression for efficiency & Initially each node is its own parent \\
\hline
Disjoint Set - Union by Rank & $O(\alpha(n))$ & Attach smaller rank tree under root of higher rank tree & Maintain rank[] or size[] & Equal ranks → increment rank \\
\hline
Path Compression in Find & Amortized $O(1)$ & Make every node on path point directly to root & Use in every find() for optimal performance & Deep trees become flat \\
\hline
Cycle Detection in Undirected Graph (DSU) & $O(E \cdot \alpha(n))$ & For every edge (u,v), check if find(u) == find(v); if yes → cycle & Apply union only when roots differ & Parallel edges, self-loops \\
\hline
Kruskal’s MST Algorithm & $O(E \log E + E \cdot \alpha(n))$ & Sort edges by weight, add to MST if it connects disjoint components & Use union-find to avoid cycles & Disconnected graph → no MST \\
\hline
Word Ladder I (BFS on String) & $O(N \cdot L^2)$ & BFS level by level, generate all one-letter transformations & Use set for fast lookup and removal & Start = end or word not present \\
\hline
Word Ladder II (All Paths) & $O(n^2 \cdot L)$ & BFS to build parent graph + backtrack all shortest paths & Level-order BFS with visited set & No path from start to end \\
\hline
0/1 Matrix (Multi-source BFS) & $O(nm)$ & Start BFS from all 0s; update distance as you expand & Initialize queue with all 0s at once & No 0s in matrix \\
\hline
Surrounded Regions (DFS) & $O(nm)$ & Mark ‘O’ connected to border first (safe), flip others to ‘X’ & Run DFS from border 'O's only & Entire board filled with ‘O’ \\
\hline
Is Graph Bipartite & $O(V + E)$ & BFS/DFS coloring: assign alternate colors; if conflict → false & Use visited and color[] arrays & Disconnected components \\
\hline
Find Eventual Safe States & $O(V + E)$ & Reverse graph + topo sort or use DFS cycle detection & Mark safe nodes via backtracking & Nodes part of cycles \\
\hline
Alien Dictionary (Topo Sort) & $O(V + E)$ & Build char graph from word pairs; Kahn's/topo sort gives order & Use visited + in-degree[] & Invalid input with cycles \\
\hline
Minimum Effort Path (BFS + Binary Search) & $O(nm \log W)$ & Binary search on max effort, check feasibility with BFS/DFS & Use priority queue for Dijkstra variant & Grid size 1x1 \\
\hline
Make a Large Island & $O(nm)$ & Label each island with ID, then try flipping 0 and count union size & Store sizes of islands in map & All 1s or all 0s grid \\
\hline
Cheapest Flight Within K Stops & $O(E \cdot K)$ & Modified BFS/queue: (node, cost, stops), prune if stops $>$ k & Use minCost[] for pruning better paths & K = 0, cycles \\
\hline
Number of Ways to Arrive at Destination & $O(E + V \log V)$ & Dijkstra + path counting (track ways[] along with dist[]) & Use mod at each addition to avoid overflow & Multiple paths with same min cost \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/graphs}
\newgeometry{margin=0.2in}
\clearpage
\section{Trie,Segment and Binary Indexed Tree-Based DSA Problems Summary Table}
\begin{longtable}{|>{\raggedright\arraybackslash}p{3.2cm}|>{\columncolor{c2}\centering\arraybackslash}p{2.5cm}|>{\columncolor{c3}\raggedright\arraybackslash}p{4.3cm}|>{\columncolor{c4}\raggedright\arraybackslash}p{3.5cm}|>{\columncolor{c5}\color{white}\raggedright\arraybackslash}p{3.5cm}|}
\hline
\rowcolor{rclr}
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endfirsthead
\hline
\textbf{Problem Name} & \textbf{Time Complexity} & \textbf{Idea to Solve} & \textbf{Optimization Tip} & \textbf{Edge Cases} \\
\hline
\endhead
Insert a Word in Trie & $O(L)$ & Traverse from root, create nodes for each char if absent & Use array/map for children & Empty word, existing prefix \\
\hline
Search a Word in Trie & $O(L)$ & Traverse char by char, return false if node missing, else check end flag & Store end-of-word boolean & Word exists as prefix but not complete \\
\hline
Delete a Word in Trie & $O(L)$ & Recursively delete only if no children and not end of another word & Track if node can be deleted during backtracking & Deleting prefix of other word \\
\hline
Autocomplete Suggestions & $O(L + k)$ & Traverse to prefix node, do DFS/BFS to collect $k$ words & Add lexicographical ordering for sorted output & Prefix not found or no suggestions \\
\hline
Count Distinct Rows in Binary Matrix & $O(n \cdot m)$ & Insert each row into a Trie (0/1 as path), count unique terminations & Use Trie instead of set for space efficiency & Duplicate rows \\
\hline
Max XOR of 2 Elements & $O(n \cdot \log M)$ & Insert bits into Trie; for each, find best XOR & Use 31-bit mask for int range & All numbers same \\
\hline
Max XOR with Given Query & $O(n \cdot \log M)$ & For each query, insert eligible elements to Trie & Sort queries + elements & No valid element for query \\
\hline
Count Different Substrings & $O(n^2)$ & Use Suffix Trie/Automaton or HashSet of substrings & Use rolling hash for faster check & All characters same \\
\hline
\end{longtable}
\clearpage
\newgeometry{margin=1in}
\input{solutions/tries&bxt}
\newgeometry{margin=0.2in}
\clearpage
\end{document}
